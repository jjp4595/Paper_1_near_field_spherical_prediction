"""
Peak impulse predictor for theta. 
"""

import preamble_functions as pre
import matplotlib.pyplot as plt #3.0.2
from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter
from scipy.signal import savgol_filter
import math
import numpy as np #1.15.4

import scipy.io as sio
import lmfit as lm
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import os
from scipy import stats
from impulse_models import *
from scipy.optimize import minimize

#plt.rcParams["font.family"] = "cmr10" #Set Graph fonts to cmr10
params = {'font.family':'serif',
        'axes.labelsize':'small',
        'xtick.labelsize':'x-small',
        'ytick.labelsize':'x-small',
#        
        'lines.markersize': 10,
        'scatter.marker': 's',
#        
        'legend.fontsize':'small',
        'legend.title_fontsize':'small',
        'legend.fancybox': True,
        'legend.framealpha': 0.5,
        'legend.shadow': False,
        'legend.frameon': True,
#        
#
        'grid.linestyle':'--',
        'grid.linewidth':'0.5',
        'lines.linewidth':'0.5'}

plt.rcParams.update(params)




#Some charge properties
charge_rad = 0.0246
charge_mass = 0.1
TNTeq = 1.2

#-----------------------------------------------------------------------------

def dataimport(folderpath):
    file = pre.FileAddressList(folderpath + r"\*.txt")
    data = pre.FileAddressList(folderpath+ r"\*gtable", 1)
    data = np.asarray([data[i][:,7] for i in range(len(file))]).T 
    smooth = np.asarray([savgol_filter(data[:,i], 101, 3) for i in range(len(file))]).T
    smooth_Icr = [data[:,i]/ (max(data[:,i])) for i in range(len(file))]     
    z_center = [(pre.standoff_func(file[i]))/((charge_mass*TNTeq)**(1/3)) for i in range(len(file))]
    z_clear = [(pre.standoff_func(file[i]) - charge_rad)/((charge_mass*TNTeq)**(1/3)) for i in range(len(file))]
    so = (np.asarray(z_center) * 0.1**(1/3)) / charge_rad    
    so_clear = (np.asarray(z_clear) * 0.1**(1/3)) / charge_rad  
    keys = ['imp', 'imp_smooth', 'icr', 'z', 'z_clear', 'so', 'so_clear']
    vals = [data, smooth, smooth_Icr, z_center, z_clear, so, so_clear]
    d = dict(zip(keys, vals))
    return d
small = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z055_16_latest\1500mm_ZL100mm_res5")
test = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\testing_z_range")
large = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z16_5")

#-----------------------------------------------------------------------------
def import_exp():
    gtable_80mm = pre.FileAddressList(os.path.join(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Near Field Sims\Sims\Latest\80mm_with_afterburn\*gtable"),1)
    theta_80mm_mesh = np.rad2deg(np.arctan(gtable_80mm[0][:,2]/0.08))
    return gtable_80mm, theta_80mm_mesh
gtable_80mm, theta_80mm_mesh = import_exp()
def overlay_exps(ax, is_crit = None):
    #Load Data for 80mm and 380mm Apollo Experimental ------------------------
    NF_80mm_exp = sio.loadmat(os.path.join(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Near Field Sims\100gPE4Sphere_80mm") )

    coords = np.append(np.arange(-100,101,25), np.arange(-100,-24,25)) 
    coords = np.append(coords, np.arange(25,101,25))
    coords = np.divide(coords,1000)
    coords_mean = np.arange(0,0.101,0.025)
    theta_exp_80mm = np.rad2deg(np.arctan(np.abs(coords)/0.08))
    theta_exp_80mm_mean = np.rad2deg(np.arctan(np.abs(coords_mean)/0.08))
    MxI_1_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,0])
    MxI_2_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,1])
    MxI_3_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,2])
    Mx_mean_80mm = np.transpose(NF_80mm_exp['MEANI'])
    if is_crit is None:
        ax.scatter(theta_exp_80mm, MxI_1_80mm/1e3, marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none', label = 'Exp')
        ax.scatter(theta_exp_80mm, MxI_2_80mm/1e3, marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm, MxI_3_80mm/1e3, marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm_mean, Mx_mean_80mm/1e3, marker="o", s=15., label = 'Exp - mean')
    else:
        ax.scatter(theta_exp_80mm, np.divide(MxI_1_80mm, max(MxI_1_80mm)), marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none', label = 'Exp')
        ax.scatter(theta_exp_80mm, np.divide(MxI_2_80mm, max(MxI_2_80mm)), marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm, np.divide(MxI_3_80mm, max(MxI_3_80mm)), marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm_mean, np.divide(Mx_mean_80mm, max(Mx_mean_80mm)), marker="o", s=15., label = 'Exp - mean')
#------------------------------------------------------------------------------    



#Graph 2 Power law-------------------------------------------------------------
def graph_powerlaw(dataset):    
    slope, intercept, r_value, p_value, std_err = stats.linregress(np.log10(dataset['z']), np.log10(dataset['imp_smooth'].max(0)/1e3))
    linear_model = intercept + slope*np.log10(dataset['z'])
    const = np.divide(dataset['imp_smooth'].max(0)/1e3, dataset['z']**slope)
    const = const.sum()/len(const)
    residuals_power = np.log10(dataset['imp_smooth'].max(0)/1e3) - linear_model
    RSS_power = np.power(residuals_power,2).sum()
    RSE_power = ( (1/(len(residuals_power)-2)) * RSS_power   )#Residual standard error https://stats.stackexchange.com/questions/57746/what-is-residual-standard-error
    text_ax1 = "$R^2 =$" + str(round(r2_score(np.log10(dataset['imp_smooth'].max(0)/1e3), linear_model), 3))
    
    if p_value < 0.0001:
        text_ax3_p = "$p < 0.0001$"
    else:
        text_ax3_p = "$p = {:.3f}$".format(p_value)
    
    if RSE_power < 0.0001:
        text_ax3_se = "$RSE < 0.0001$"
    else:
        text_ax3_se = "$RSE = {:.3f}$".format(RSE_power)
    
    
    text_ax2 = "$f(x) = {%.3f}.x^{%.3f}$" % (const, slope)
    
    fig1, [ax1, ax3, ax2] = plt.subplots(1,3)
    fig1.set_size_inches(7, 2.5)
    
    ax1.scatter(np.log10(dataset['z']), np.log10(dataset['imp_smooth'].max(0)/1e3), marker = 's',facecolors = 'none', edgecolors='k', s = 10., label = 'CFD data')
    ax1.plot(np.log10(dataset['z']), linear_model, 'k', label='fitted model')
    ax1.plot(np.log10(dataset['z']), linear_model + (2 * RSE_power), '--k', alpha = 0.2, label='95% PI')
    ax1.plot(np.log10(dataset['z']), linear_model - (2 * RSE_power), '--k', alpha = 0.2)
    ax1.text(0.1, 0.25, text_ax1, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.text(0.1, 0.15, text_ax3_p, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.text(0.1, 0.05, text_ax3_se, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.set_ylabel('log(peak specific impulse (MPa.ms))')
    ax1.set_xlabel('log(z ' + r'$(m.kg^{\frac{1}{3}})$' +')')
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    

    ax2.scatter(dataset['z'], dataset['imp_smooth'].max(0)/1e3, marker = 's',facecolors = 'none', edgecolors='k', s = 10., label = 'CFD data')
    ax2.plot(dataset['z'], const * dataset['z']**slope, 'k', label='fitted model')
    ax2.text(0.25, 0.9, text_ax2, fontsize = 'small', transform=ax2.transAxes)
    ax2.set_ylabel('peak specific impulse (MPa.ms)')
    ax2.set_xlabel('z ' + r'$(m.kg^{\frac{1}{3}})$')
    ax2.minorticks_on()
    ax2.set_ylim(0,math.ceil(dataset['imp_smooth'].max()/1e3))
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5)
    
    ax3.scatter(np.log10(dataset['z']), residuals_power,marker = 's',facecolors = 'none', edgecolors='k',  s = 10., label = 'Residuals')
    ax3.set_ylim(-0.1,0.1)
    ax3.set_ylabel('Residual')
    ax3.set_xlabel('log(z ' + r'$(m.kg^{\frac{1}{3}})$' +')')
    ax3.minorticks_on()
    ax3.grid(which='minor', alpha=0.2)
    ax3.grid(which='major', alpha=0.5)
    
    handles, labels = ax1.get_legend_handles_labels()
    ax1.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    ax2.locator_params(axis = 'both',tight=True, nbins=6)
    ax3.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    return fig1, slope, intercept
fig_power, small['slope'], small['const'] = graph_powerlaw(small)
fig_power.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\power_fit_small.pdf"), format = 'pdf')
fig_power, large['slope'], large['const'] = graph_powerlaw(large)
fig_power.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\power_fit_large.pdf"), format = 'pdf')
fig_power, test['slope'], test['const'] = graph_powerlaw(test)
#-----------------------------------------------------------------------------

#Graph1 - dataset- overview ---------------------------------------------------
def graph_dataset_overview():   
    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z_center, smooth1/1e3, levels = np.linspace(0,15,50), cmap = plt.cm.magma_r)
    cbar = fig0.colorbar(CS, format='%.1f' ,ticks = np.linspace(0,15,7))
    ax.xaxis.set_major_locator(LinearLocator(5)) 
    ax.yaxis.set_major_locator(LinearLocator(5))
    ax.xaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    cbar.ax.set_ylabel('peak specific impulse (MPa.ms)')
    ax.set_ylabel('scaled distance, z ' + r'$(m.kg^{\frac{1}{3}}$)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_overview.pdf"), format = 'pdf')
    
    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(3, 2.5)
    crs = np.asarray(testing_zrange_z_center)  
    theta_test = np.linspace(0,80, num=len(smooth))
    theta_test = np.repeat(theta_test[:,np.newaxis], len(crs), 1)       
    crs = np.repeat(crs[:,np.newaxis], len(theta_test), 1)
    crs = crs.transpose()      
    CS = ax.contourf(theta_test, crs, smooth/1e3, levels = np.linspace(0,15,50), cmap = plt.cm.magma_r)
    cbar = fig0.colorbar(CS, format='%.1f' ,ticks = np.linspace(0,15,7))
    ax.xaxis.set_major_locator(LinearLocator(5)) 
    ax.yaxis.set_major_locator(LinearLocator(5))
    ax.xaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    cbar.ax.set_ylabel('peak specific impulse (MPa.ms)')
    ax.set_ylabel('scaled distance, z ' + r'$(m.kg^{\frac{1}{3}}$)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_overview.pdf"), format = 'pdf')     

    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(2.5, 2.5)
    ax.plot(theta[:,0], peak_impulse[:,0]/1e3, lw = 0.75, ls = '-', c='k', label = 'z = lower')
    ax.plot(theta[:,-1], peak_impulse[:,-1]/1e3, lw = 0.75, ls = '--', c='k', label = 'z = upper')
    ax.set_xlabel('incident wave angle (degrees)')
    ax.set_ylabel('peak specific impulse (MPa.ms)')
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles, labels, loc='upper right', prop={'size':6})
    ax.minorticks_on()
    ax.set_xlim(0,80)
    ax.set_ylim(0,12)
    ax.grid(which='minor', alpha=0.2)
    ax.grid(which='major', alpha=0.5)
    plt.tight_layout()    
    fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_ex1.pdf"), format = 'pdf')     
   
    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(2.5, 2.5)
    ax.plot(np.linspace(0,80,200), testing_zrange[:,0]/1e3, lw = 0.75, ls = '-', c='k', label = 'z = lower')
    ax.plot(np.linspace(0,80,200), testing_zrange[:,-1]/1e3, lw = 0.75, ls = '--', c='k', label = 'z = upper')
    ax.set_xlabel('incident wave angle (degrees)')
    ax.set_ylabel('peak specific impulse (MPa.ms)')
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles, labels, loc='upper right', prop={'size':6})
    ax.minorticks_on()
    ax.set_xlim(0,80)
    ax.set_ylim(0,12)
    ax.grid(which='minor', alpha=0.2)
    ax.grid(which='major', alpha=0.5)
    plt.tight_layout()  
    fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_ex2.pdf"), format = 'pdf')     

    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(2.5, 2.5)
    ax.plot(theta, smooth1/1e3, lw = 0.75, ls = '-', c='k')
    ax.plot(theta, peak_impulse/1e3, lw = 0.75, ls = '--', alpha = 0.4, c='k')
    ax.set_xlabel('incident wave angle (degrees)')
    ax.set_ylabel('peak specific impulse (MPa.ms)')
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles, labels, loc='upper right', prop={'size':6})
    ax.minorticks_on()
    ax.set_xlim(0,80)
    ax.set_ylim(0,12)
    ax.grid(which='minor', alpha=0.2)
    ax.grid(which='major', alpha=0.5)
    plt.tight_layout()
    
    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(2.5, 2.5)
    ax.plot(np.linspace(0,80,200), smooth/1e3, lw = 0.75, ls = '-', c='k')
    ax.plot(np.linspace(0,80,200), testing_zrange/1e3, lw = 0.75, ls = '--', alpha = 0.2, c='k')
    ax.set_xlabel('incident wave angle (degrees)')
    ax.set_ylabel('peak specific impulse (MPa.ms)')
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles, labels, loc='upper right', prop={'size':6})
    ax.minorticks_on()
    ax.set_xlim(0,80)
    ax.set_ylim(0,12)
    ax.grid(which='minor', alpha=0.2)
    ax.grid(which='major', alpha=0.5)
    plt.tight_layout()
    

graph_dataset_overview()
#-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
#Model fitting Stuff that needs refinement 
#------------------------------------------------------------------------------

#1) One Gaussian
def gauss_curve(x, *params):
    y1 = np.zeros_like(x)

    y1 = params[1] * np.exp( -((x - params[0])**2 / (2*(params[2]**2)) ) )

    y = y1
    return y

#Objective function to be minimised. Loss function is MSE.
def lm_residual(params, x, ytrue):
    cen1 = params['cen1'].value
    amp1 = params['amp1'].value
    wid1 = params['wid1'].value

    args = [cen1, amp1, wid1]
    
    global current_cost
    current_cost = mean_squared_error(ytrue, gauss_curve(x, *args))  
    return current_cost
params = lm.Parameters()
params['cen1'] = lm.Parameter(name='cen1', value = 0.5, vary = 'false', min = 0.4, max = 0.6)
params['amp1'] = lm.Parameter(name='amp1', value = 0.5, min=0, max=1)
params['wid1'] = lm.Parameter(name='wid1', value = 0.5, min=0, max=1)   



#2) Two Gaussian 
params2 = lm.Parameters()
params2['cen1'] = lm.Parameter(name='cen1', value = 0.5, vary = 'false', min = 0.4, max = 0.6)
params2['amp1'] = lm.Parameter(name='amp1', value = 0.5, min=0, max=1)
params2['wid1'] = lm.Parameter(name='wid1', value = 0.5, min=0, max=1)  
params2['cen2'] = lm.Parameter(name='cen2', value = 0.5, vary = 'false', min = 0.4, max = 0.6)
params2['amp2'] = lm.Parameter(name='amp2', value = 0.5, min=0, max=1)
params2['wid2'] = lm.Parameter(name='wid2', value = 0.5, min=0, max=1)  
def gauss_two_curve(x, *params):
    y1 = np.zeros_like(x)
    y2 = np.zeros_like(x)
    y1 = params[1] * np.exp( -((x - params[0])**2 / (2*(params[2]**2)) ) )
    y2 = params[4] * np.exp( -((x - params[3])**2 / (2*(params[5]**2)) ) )
    y = y1 + y2
    return y

#Amplitude penalty function
def pen1(param1, param2):
    delta = param2 - param1
    out = max(0,delta)
    return out**0.5  

#Objective function to be minimised. Loss function is MSE.
def lm_residual2(params, x, ytrue):
    cen1 = params['cen1'].value
    amp1 = params['amp1'].value
    wid1 = params['wid1'].value
    cen2 = params['cen2'].value
    amp2 = params['amp2'].value
    wid2 = params['wid2'].value


    args = [cen1, amp1, wid1, cen2, amp2, wid2]
    reg1 = 5
    current_cost = ( (mean_squared_error(ytrue, gauss_two_curve(x, *args)))**2 + (reg1 * pen1(amp1, amp2)**2) ) **0.5
    return current_cost

#-----------------------------------------------------------------------------

#Henrych optimal ------------------------------------------------------------------
def Henrych_i_fit(x, A0):
    """
    x is theta
    Calculating specific impulse
    A0 = (Nxw + Ux) / 4pi
    W = charge mass
    """
    W = 0.1
    a = 0.08-charge_rad
    i = ((A0 * W) / (a**2)) * np.cos(np.deg2rad(x))**4
    return i
def henrych_residual(params, y_true):
    return mean_squared_error(y_true, Henrych_i_fit(np.linspace(-80,80,num=400), *params))




#impulse distribution in theta -----------------------------------------------
def my_model_graphs_exact():
    #Fitting model
    data_o = np.concatenate([np.flipud(np.asarray(smooth1_Icr).mean(0)), np.asarray(smooth1_Icr).mean(0)])
    data = (data_o - min(data_o)) / (max(data_o) - min(data_o))  
    x = np.linspace(0,80,len(data))
    x = (x - min(x)) / (max(x) - min(x))
    result = lm.minimize(lm_residual, params, method = 'least_squares', args = (x, data))
    gaussmod = gauss_curve(x, result.params['cen1'].value, result.params['amp1'].value, result.params['wid1'].value)      
    #Linearregressions
    #poly6 = np.polynomial.polynomial.Polynomial.fit(x, data, 6)
    
    #Gaussian - 1 -------------------------------------------------------------
    fig, [ax0, ax1, ax2] = plt.subplots(1,3)
    fig.set_size_inches(7,2.5)    
    #CFD
    ax0.plot(theta.mean(1), np.asarray(smooth1_Icr).mean(0), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(theta.mean(1), np.asarray(smooth1_Icr).min(0), np.asarray(smooth1_Icr).max(0), color = 'silver', alpha = 0.2, label = 'CFD - range')       
    #Models
    ax0.plot(theta.mean(1), gaussmod[int(len(gaussmod)/2)::], 'r:', label = 'Model fit')
    
    text_gaussian1 = r"$f(\theta) = exp \left( \frac{-(\theta-0.5)^2}{2 \times {%.3f}^2} \right)$" % (result.params['wid1'].value)    
    ax1.text(0.4, 0.2, text_gaussian1, fontsize = 'x-small', transform=ax1.transAxes)
   
    
    ax1.scatter(theta.mean(1), np.asarray(smooth1_Icr).mean(0) - gaussmod[int(len(gaussmod)/2)::], c = 'k' , s=1.)
    ax1.set_ylim(-0.1, 0.1)
    
    RSS = np.power(np.asarray(smooth1_Icr).mean(0) - gaussmod[int(len(gaussmod)/2)::],2).sum()
    RSE = ( (1/(len(np.asarray(smooth1_Icr).mean(0) - gaussmod[int(len(gaussmod)/2)::])-2)) * RSS  )
    if RSE < 0.0001:
        text_RSE = "$RSE < 0.0001$"
    else:
        text_RSE = "$RSE = {:.3f}$".format(RSE)
    
    res1 = stats.probplot(np.asarray(smooth1_Icr).mean(0) - gaussmod[int(len(gaussmod)/2)::], plot=ax2)
    ax2.text(0.55, 0.25, r"$R^2 = $"+str(round(res1[1][2]**2, 3)), fontsize = 'x-small', transform=ax2.transAxes)
    ax2.get_lines()[0].set_marker('s')
    ax2.get_lines()[0].set_markerfacecolor('k')
    ax2.get_lines()[0].set_markeredgecolor('k')
    ax2.get_lines()[0].set_markersize(1.)    
    ax2.set_title("")

    #axis settings
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('Ir / Ir Max')
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_gaussian1.pdf', format = 'pdf')
    
   
    #Henrych ------------------------------------------------------------
    x0 = [0.1]
    hen_mod = minimize(henrych_residual, x0, args=(data), method = 'BFGS')
    rem_actual = Henrych_i((0.08-charge_rad), charge_rad, 7900, 5.53, 1660, np.linspace(0,80,200))
    
    fig, [ax0, ax1] = plt.subplots(1,2)
    fig.set_size_inches(5,2.5)   
    #CFD
    ax0.plot(theta.mean(1), np.asarray(smooth1_Icr).mean(0), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(theta.mean(1), np.asarray(smooth1_Icr).min(0), np.asarray(smooth1_Icr).max(0), color = 'silver', alpha = 0.2, label = 'CFD - range')       
    #Models
    ax0.plot(np.linspace(0,80,num=200), Henrych_i_fit(np.linspace(0,80,num=200), hen_mod['x'][0]), 'r:', label = 'Model fit')
    ax0.plot(np.linspace(0,80,num=200), rem_actual/max(rem_actual), 'c--', label = 'Model actual')
    texts = "TO BE SORTED"    
    ax1.text(0.4, 0.2, texts, fontsize = 'x-small', transform=ax1.transAxes)      
    ax1.scatter(theta.mean(1), np.asarray(smooth1_Icr).mean(0) - rem_actual/max(rem_actual), c = 'k', s=1.)
    ax1.set_ylim(-0.1, 0.1)
    #axis settings
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('Ir / Ir Max')
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_henrych.pdf', format = 'pdf')
    
    #RPB-MCEER ------------------------------------------------------------
    RPB_MCEER_exp = RPB_MCEER_i(0.1*1.2, 0.08-charge_rad, 80)
    RPB_MCEER_exp_model_inter = np.interp(theta.mean(1), RPB_MCEER_exp[2][200,200::], RPB_MCEER_exp[3][200,200::] / max(RPB_MCEER_exp[3][200,200::]))
    #impulse dist
    fig, [ax0, ax1] = plt.subplots(1,2)
    fig.set_size_inches(5,2.5)   
    #CFD
    ax0.plot(theta.mean(1), np.asarray(smooth1_Icr).mean(0), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(theta.mean(1), np.asarray(smooth1_Icr).min(0), np.asarray(smooth1_Icr).max(0), color = 'silver', alpha = 0.2, label = 'CFD - range')       
    #Models
    ax0.plot(theta.mean(1), RPB_MCEER_exp_model_inter , 'r:', label = 'Model fit')   
    texts = "TO BE SORTED"    
    ax1.text(0.4, 0.2, texts, fontsize = 'x-small', transform=ax1.transAxes)       
    ax1.scatter(theta.mean(1), np.asarray(smooth1_Icr).mean(0) - RPB_MCEER_exp_model_inter, c = 'k', s=1.)
    ax1.set_ylim(-0.1, 0.1)
    #axis settings
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('Ir / Ir Max')
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_RPB_MCEER.pdf', format = 'pdf')    
    
    return gaussmod
gaussmod_small = my_model_graphs_exact()



#impulse distribution in theta -----------------------------------------------
def my_model_graphs_large():
    
    data_o = np.concatenate([np.flipud(np.asarray(smooth_Icr).max(0)), np.asarray(smooth_Icr).max(0)])
    data = (data_o - min(data_o)) / (max(data_o) - min(data_o))
    x = np.linspace(0,80,len(data))
    x = (x - min(x)) / (max(x) - min(x))       
    #Nonlinear regression -gaussians
    result = lm.minimize(lm_residual, params, method = 'least_squares', args = (x, data))
    gaussmod = gauss_curve(x, result.params['cen1'].value, result.params['amp1'].value, result.params['wid1'].value)
               
    #Gaussian - 1 -------------------------------------------------------------
    fig, [ax0, ax1, ax2] = plt.subplots(1,3)
    fig.set_size_inches(7,2.5)    
    #CFD
    ax0.plot(theta.mean(1), np.asarray(smooth_Icr).mean(0), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(theta.mean(1), np.asarray(smooth_Icr).min(0), np.asarray(smooth_Icr).max(0), color = 'silver', alpha = 0.2, label = 'CFD - range')       
    #Models
    ax0.plot(theta.mean(1), gaussmod[int(len(gaussmod)/2)::], 'r:', label = 'Model fit')    
    text_gaussian1 = r"$f(\theta) = exp \left( \frac{-(\theta-0.5)^2}{2 \times {%.3f}^2} \right)$" % (result.params['wid1'].value)    
    ax1.text(0.4, 0.2, text_gaussian1, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.scatter(theta.mean(1), np.asarray(smooth_Icr).mean(0) - gaussmod[int(len(gaussmod)/2)::], c = 'k' , s=1.)
    ax1.set_ylim(-0.1, 0.1)
    
    res1 = stats.probplot(np.asarray(smooth_Icr).mean(0) - gaussmod[int(len(gaussmod)/2)::], plot=ax2)
    ax2.text(0.55, 0.25, r"$R^2 = $"+str(round(res1[1][2]**2, 3)), fontsize = 'x-small', transform=ax2.transAxes)
    ax2.get_lines()[0].set_marker('s')
    ax2.get_lines()[0].set_markerfacecolor('k')
    ax2.get_lines()[0].set_markeredgecolor('k')
    ax2.get_lines()[0].set_markersize(1.)    
    ax2.set_title("")
    #axis settings
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('Ir / Ir Max')
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_gaussian1_largez.pdf', format = 'pdf')      
    return gaussmod
gaussmod_large = my_model_graphs_large()      



#Build surface from Guassian Eq and power law.
def plot_model_surfaces():
    #Single gauss - small
    crs = np.linspace(clear_standoff.min(), clear_standoff.max(), num = len(Apollo_gtable))
    peak_I_test = np.multiply(np.power(crs, slope), 10**intercept)    
    y_gauss = np.repeat(gaussmod_small[int(len(gaussmod_small)/2)::][:,np.newaxis], len(crs), 1) #use numpy broadcasting rules    
    theta_test = np.linspace(0,80, num=len(y_gauss))
    theta_test = np.repeat(theta_test[:,np.newaxis], len(crs), 1)    
    test_impulses = np.multiply( y_gauss , peak_I_test )
    crs = np.repeat(crs[:,np.newaxis], len(y_gauss), 1)
    crs = crs.transpose()    
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(theta_test, crs, test_impulses, levels = np.arange(0,15,0.25), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('peak specific impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_gaussian1.pdf', format = 'pdf')
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(theta_test, crs, test_impulses-(smooth1/1e3), levels = np.arange(0,1,0.02), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('peak specific impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_gaussian2.pdf', format = 'pdf')
    
    #Single Gauss - large
    crs = np.linspace(testing_zrange_so.min(), testing_zrange_so.max(), num = len(testing_zrange_file))
    peak_I_test = np.multiply(np.power(crs, slope2), 10**intercept2)    
    y_gauss = np.repeat(gaussmod_large[int(len(gaussmod_large)/2)::][:,np.newaxis], len(crs), 1) #use numpy broadcasting rules    
    theta_test = np.linspace(0,80, num=len(y_gauss))
    theta_test = np.repeat(theta_test[:,np.newaxis], len(crs), 1)    
    test_impulses2 = np.multiply( y_gauss , peak_I_test )
    crs = np.repeat(crs[:,np.newaxis], len(y_gauss), 1)
    crs = crs.transpose()    
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(theta_test, crs, test_impulses2, levels = np.arange(0,15,0.25), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('peak specific impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_gaussian1.pdf', format = 'pdf')
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(theta_test, crs, test_impulses2-(smooth/1e3), levels = np.arange(0,1,0.02), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('peak specific impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_gaussian2.pdf', format = 'pdf')
    return test_impulses, test_impulses2
gauss_small, gauss_large = plot_model_surfaces()






def TotalImpulseSurfaces():
    max_target_length = 2.5
    upper_theta = 80
    theta_lim = np.linspace(0,upper_theta,80)   
    R = np.divide(max_target_length, np.tan(np.deg2rad(upper_theta))) 
    
    #Small Dataset
    z = z_dataset[0,:]
    Imp_CFD = np.zeros((len(z), len(theta_lim)))
    Imp_gauss = np.zeros_like(Imp_CFD)
    for i in range(len(z)):
        for j in range(len(theta_lim)):       
            Imp_CFD[i,j] = Impulse_CFD(smooth1[:,i], R, theta_lim[j], np.linspace(0,80,200))
            Imp_gauss[i,j] = Impulse_CFD(gauss_small[:,i], R, theta_lim[j], np.linspace(0,80,200))
    
    crs = np.linspace(clear_standoff.min(), clear_standoff.max(), num = len(Apollo_gtable))
    crs = np.repeat(crs[:,np.newaxis], len(theta_lim), 1)
    crs = crs.T
    theta_test = np.repeat(theta_lim[:,np.newaxis], len(Apollo_gtable), 1)    
    target_rad = np.multiply(np.tan(np.deg2rad(theta_test)), R)  
   
    
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, crs, Imp_gauss.T, levels = np.arange(0,15,0.25), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('total impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('target radius (m)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_totalimpulse_gauss.pdf', format = 'pdf')

    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, crs, Imp_gauss.T - Imp_CFD.T/1e3, levels = np.arange(0,5,0.025), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('total impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('target radius (m)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_totalimpulse_gauss2.pdf', format = 'pdf')
 
    #Large Z Dataset
    z = np.asarray(testing_zrange_z)
    Imp_CFD = np.zeros((len(z), len(theta_lim)))
    Imp_gauss = np.zeros_like(Imp_CFD)
    for i in range(len(z)):
        for j in range(len(theta_lim)):       
            Imp_CFD[i,j] = Impulse_CFD(smooth[:,i], R, theta_lim[j], np.linspace(0,80,200))
            Imp_gauss[i,j] = Impulse_CFD(gauss_large[:,i], R, theta_lim[j], np.linspace(0,80,200))
    
    crs = np.linspace(testing_zrange_so.min(), testing_zrange_so.max(), num = len(testing_zrange_file)) 
    crs = np.repeat(crs[:,np.newaxis], len(theta_lim), 1)
    crs = crs.T
    theta_test = np.repeat(theta_lim[:,np.newaxis], len(z), 1)    
    target_rad = np.multiply(np.tan(np.deg2rad(theta_test)), R)  
   
    
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, crs, Imp_gauss.T, levels = np.arange(0,20,0.25), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('total impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('target radius (m)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_totalimpulse_gauss.pdf', format = 'pdf')

    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, crs, Imp_gauss.T - Imp_CFD.T/1e3, levels = np.arange(0,10,0.025), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, ax=ax)
    cbar.ax.invert_yaxis()
    cbar.ax.set_ylabel('total impulse (MPa.ms)')
    ax.set_ylabel('standoff (clear charge radii)')
    ax.set_xlabel('target radius (m)')
    plt.tight_layout()
    fig_test.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_totalimpulse_gauss2.pdf', format = 'pdf')
#TotalImpulseSurfaces()

