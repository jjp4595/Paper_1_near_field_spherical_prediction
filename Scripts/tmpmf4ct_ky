"""
Peak impulse predictor for theta. 
"""

import preamble_functions as pre
import matplotlib.pyplot as plt #3.0.2
from matplotlib.lines import Line2D
from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter
from scipy.signal import savgol_filter
import math
import numpy as np #1.15.4

import scipy.io as sio
import lmfit as lm
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import os
from scipy import stats
from impulse_models import *
from MCEER_curves import MCEER
from scipy.optimize import minimize
from scipy.interpolate import interp2d, interp1d, griddata

#plt.rcParams["font.family"] = "cmr10" #Set Graph fonts to cmr10
params = {'font.family':'serif',
        'axes.labelsize':'small',
        'xtick.labelsize':'x-small',
        'ytick.labelsize':'x-small', 
        'axes.linewidth':0.5,
        
        'xtick.major.width':0.5,
        'xtick.minor.width':0.4,
        'ytick.major.width':0.5,
        'ytick.minor.width':0.4,
        'xtick.major.size':3.0,
        'xtick.minor.size':1.5,
        'ytick.major.size':3.0,
        'ytick.minor.size':1.5,
        
        'legend.fontsize':'small',
        'legend.title_fontsize':'small',
        'legend.fancybox': False,
        'legend.framealpha': 1,
        'legend.shadow': False,
        'legend.frameon': True,
        'legend.edgecolor':'black',
        'patch.linewidth':0.5,
        
        'scatter.marker': 's',
        
        'grid.linewidth':'0.5',
        
        'lines.linewidth':'0.5'}
plt.rcParams.update(params)



def roundup(x, base=10):
    return int(base * math.ceil(x/base)) 
def rounddwn(x, base=10):
    return int(base * math.floor(x/base))

#For rounding with decimals...
import decimal
def round_up(x, place=0):
    context = decimal.getcontext()
    # get the original setting so we can put it back when we're done
    original_rounding = context.rounding
    # change context to act like ceil()
    context.rounding = decimal.ROUND_CEILING

    rounded = round(decimal.Decimal(str(x)), place)
    context.rounding = original_rounding
    return float(rounded)
def round_dwn(x, place=0):
    context = decimal.getcontext()
    # get the original setting so we can put it back when we're done
    original_rounding = context.rounding
    # change context to act like ceil()
    context.rounding = decimal.ROUND_FLOOR

    rounded = round(decimal.Decimal(str(x)), place)
    context.rounding = original_rounding
    return float(rounded)



#Some charge properties
charge_rad = 0.0246
cm = 0.1
TNTeq = 1

#-----------------------------------------------------------------------------

def dataimport(folderpath, cm, TNTeq, sav=151):
    file = pre.FileAddressList(folderpath + r"\*.txt")
    data = pre.FileAddressList(folderpath+ r"\*gtable", 1)
    data = np.asarray([data[i][:,7] for i in range(len(file))]).T 
    smooth = np.asarray([savgol_filter(data[:,i], sav, 3) for i in range(len(file))]).T
    smooth_Icr = np.asarray([smooth[:,i]/ (max(smooth[:,i])) for i in range(len(file))]).T     
    z_center = [(pre.standoff_func(file[i]))/((cm*TNTeq)**(1/3)) for i in range(len(file))]
    z_clear = [(pre.standoff_func(file[i]) - charge_rad)/((cm*TNTeq)**(1/3)) for i in range(len(file))]
    z_center = np.asarray(z_center)
    z_clear = np.asarray(z_clear)
    so = (np.asarray(z_center) * ((cm*TNTeq)**(1/3)))    
    so_clear = (np.asarray(z_clear) *((cm*TNTeq)**(1/3)))  
    keys = ['imp', 'imp_smooth', 'icr', 'z', 'z_clear', 'so', 'so_clear']
    vals = [data, smooth, smooth_Icr, z_center, z_clear, so, so_clear]
    d = dict(zip(keys, vals))
    return d
small = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z055_16_latest\1500mm_ZL100mm_res5", cm, TNTeq)
test = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\testing_z_range", cm, TNTeq)
large = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z16_5", cm, TNTeq)
#small_n = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\1500mm_ZL100mm_res5n", cm, TNTeq)
#large_n = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z16_5n", cm, TNTeq)
#-----------------------------------------------------------------------------
def import_exp():
    gtable_80mm = pre.FileAddressList(os.path.join(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Near Field Sims\Sims\Latest\80mm_with_afterburn\*gtable"),1)
    theta_80mm_mesh = np.rad2deg(np.arctan(gtable_80mm[0][:,2]/0.08))
    return gtable_80mm, theta_80mm_mesh
gtable_80mm, theta_80mm_mesh = import_exp()
def overlay_exps(ax, is_crit = None):
    #Load Data for 80mm and 380mm Apollo Experimental ------------------------
    NF_80mm_exp = sio.loadmat(os.path.join(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Near Field Sims\100gPE4Sphere_80mm") )

    coords = np.append(np.arange(-100,101,25), np.arange(-100,-24,25)) 
    coords = np.append(coords, np.arange(25,101,25))
    coords = np.divide(coords,1000)
    coords_mean = np.arange(0,0.101,0.025)
    theta_exp_80mm = np.rad2deg(np.arctan(np.abs(coords)/0.08))
    theta_exp_80mm_mean = np.rad2deg(np.arctan(np.abs(coords_mean)/0.08))
    MxI_1_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,0])
    MxI_2_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,1])
    MxI_3_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,2])
    Mx_mean_80mm = np.transpose(NF_80mm_exp['MEANI'])
    if is_crit is None:
        ax.scatter(theta_exp_80mm, MxI_1_80mm/1e3, marker="x", s=10., color='grey', edgecolors='none', label = 'Exp')
        ax.scatter(theta_exp_80mm, MxI_2_80mm/1e3, marker="x", s=10., color='grey', edgecolors='none')
        ax.scatter(theta_exp_80mm, MxI_3_80mm/1e3, marker="x", s=10., color='grey', edgecolors='none')
        ax.scatter(theta_exp_80mm_mean, Mx_mean_80mm/1e3, marker="o", s=10., edgecolor = 'k', label = 'Exp - mean')
    else:
        ax.scatter(theta_exp_80mm, np.divide(MxI_1_80mm, max(MxI_1_80mm)), marker="x", s=10., color='grey', edgecolors='none', label = 'Exp')
        ax.scatter(theta_exp_80mm, np.divide(MxI_2_80mm, max(MxI_2_80mm)), marker="x", s=10., color='grey', edgecolors='none')
        ax.scatter(theta_exp_80mm, np.divide(MxI_3_80mm, max(MxI_3_80mm)), marker="x", s=10., color='grey', edgecolors='none')
        ax.scatter(theta_exp_80mm_mean, np.divide(Mx_mean_80mm, max(Mx_mean_80mm)), marker="o", edgecolor = 'k', s=10., label = 'Exp - mean')
#------------------------------------------------------------------------------    



#Graph 2 Power law-------------------------------------------------------------
def graph_powerlaw(dataset):    
    slope, intercept, r_value, p_value, std_err = stats.linregress(np.log10(dataset['z']), np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))))
    linear_model = intercept + slope*np.log10(dataset['z'])
    const = np.divide(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3)), dataset['z']**slope)
    const = const.sum()/len(const)
    residuals_power = np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))) - linear_model
    RSS_power = np.power(residuals_power,2).sum()
    RSE_power = ( (1/(len(residuals_power)-2)) * RSS_power   )#Residual standard error https://stats.stackexchange.com/questions/57746/what-is-residual-standard-error
    text_ax1 = "$R^2 =$" + str(round(r2_score(np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))), linear_model), 3))
    
    if p_value < 0.0001:
        text_ax3_p = "$p < 0.0001$"
    else:
        text_ax3_p = "$p = {:.3f}$".format(p_value)
    
    if RSE_power < 0.0001:
        text_ax3_se = "$RSE < 0.0001$"
    else:
        text_ax3_se = "$RSE = {:.3f}$".format(RSE_power)
    
    
    text_ax2 = "$f(Z) = {%.3f}Z^{%.3f}$" % (const, slope)
     
    fig1, [ax1, ax3, ax2] = plt.subplots(1,3)
    fig1.set_size_inches(7, 2.5)
    
    ax1.plot(np.log10(dataset['z']), linear_model, 'k', label='fitted model')
    #ax1.plot(np.log10(dataset['z']), linear_model + (2 * RSE_power), '--k', alpha = 0.2, label='95% PI')
    ax1.plot(np.log10(dataset['z']), linear_model - (2 * RSE_power), '--k', alpha = 0.2)
    ax1.scatter(np.log10(dataset['z']), np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))), marker = 's',facecolors = 'white', edgecolors='k', s = 10., label = 'CFD data')
    ax1.text(0.1, 0.25, text_ax1, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.text(0.1, 0.15, text_ax3_p, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.text(0.1, 0.05, text_ax3_se, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.set_ylabel('log(Peak scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$))', wrap = True, fontsize = 'x-small')
    ax1.set_xlabel('log(Z ' + r'$(m.kg^{1/3})$' +')')
    ax1.minorticks_on()
    ax1.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax1.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax1.set_xlim(round_dwn(np.log10(dataset['z']).min(), 1),round_up(np.log10(dataset['z']).max(), 1))
    ax1.set_ylim(round_dwn(linear_model.min(), 1),round_up(linear_model.max(), 1))
    
    ax2.plot(dataset['z'], const * dataset['z']**slope, 'k', label='fitted model')
    ax2.scatter(dataset['z'], dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3)), marker = 's',facecolors = 'white', edgecolors='k', s = 10., label = 'CFD data')
    ax2.text(0.25, 0.9, text_ax2, fontsize = 'small', transform=ax2.transAxes)
    ax2.set_ylabel('Peak scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', wrap = True, fontsize = 'x-small')
    ax2.set_xlabel('Z ' + r'$(m/kg^{1/3})$')
    ax2.minorticks_on()
    ax3.set_xlim(round_dwn(np.log10(dataset['z']).min(), 1),round_up(np.log10(dataset['z']).max(), 1))
    ax3.set_ylim(0,roundup((const * dataset['z']**slope).max(), base = 5))
    
    ax2.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax2.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    
    ax3.scatter(np.log10(dataset['z']), residuals_power,marker = 's',facecolors = 'white', edgecolors='k',  s = 10., label = 'Residuals')
    ax3.set_xlim(round_dwn(np.log10(dataset['z']).min(), 1),round_up(np.log10(dataset['z']).max(), 1))
    ax3.set_ylim(round_dwn(residuals_power.min(), 1),round_up(residuals_power.max(), 1))
    ax3.set_ylabel('Residual')
    ax3.set_xlabel('log(Z ' + r'$(m/kg^{1/3})$' +')')
    ax3.minorticks_on()
    ax3.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax3.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    
    handles, labels = ax1.get_legend_handles_labels()
    ax1.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    ax2.locator_params(axis = 'both',tight=True, nbins=6)
    ax3.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    return fig1, slope, const
fig_power, small['slope'], small['const'] = graph_powerlaw(small)
fig_power.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\power_fit_small.pdf"), format = 'pdf')
fig_power, large['slope'], large['const'] = graph_powerlaw(large)
fig_power.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\power_fit_large.pdf"), format = 'pdf')
#fig_power, test['slope'], test['const'] = graph_powerlaw(test)
#-----------------------------------------------------------------------------

#Graph1 - dataset- overview ---------------------------------------------------
def graph_dataset_overview(dataset, reduced=None):  

    theta = np.repeat(np.linspace(0,80, dataset['imp'].shape[0])[:,np.newaxis], dataset['imp'].shape[1], 1) 
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, dataset['imp'].shape[0], 0)
    

    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z,dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3)), levels = np.linspace(0,25,50), cmap = plt.cm.magma_r)
    cbar = fig0.colorbar(CS, format='%.1f' ,ticks = np.linspace(0,25,6))
    # ax.xaxis.set_major_locator(LinearLocator(5)) 
    # ax.yaxis.set_major_locator(LinearLocator(5))
    # ax.xaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    # ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    
    
    plt.tight_layout()

    # fig3, ax = plt.subplots(1,1)
    # fig3.set_size_inches(2.5, 2.5)
    # ax.plot(theta, dataset['icr'], lw = 0.5, ls = '-', c='k')
    # ax.set_xlabel('Angle of incidence (degrees)')
    # ax.set_ylabel('Normalised peak specific impulse')
    # ax.minorticks_on()
    # ax.set_xlim(0,80)
    # ax.set_ylim(0,1)
    # ax.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    # ax.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    # plt.tight_layout()
    
    if reduced == None:
        fig2, ax = plt.subplots(1,1)
        fig2.set_size_inches(2.5, 2.5)
        #ax.plot(theta, dataset['imp']/1e3/((cm*TNTeq)**(1/3)), lw = 0.5, ls = '--', c='r')
        ax.plot(theta, dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3)), lw = 0.75, ls = '-', c='k')
        ax.set_xlabel('Angle of incidence (degrees)')
        ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
        ax.minorticks_on()
        ax.set_xlim(0,80)
        ax.set_ylim(0,roundup(dataset['imp'].max()/1e3/((cm*TNTeq)**(1/3)), base = 5))
        ax.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
        ax.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
        plt.tight_layout()
    
    else:
        inds = [5,8,11,14,17]
        fig2, ax = plt.subplots(1,1)
        fig2.set_size_inches(2.5, 2.5)
        #ax.plot(theta[:,4::], dataset['imp'][:,4::]/1e3/((cm*TNTeq)**(1/3)), lw = 0.5, ls = '--', c='r')
        ax.plot(theta[:,inds], dataset['imp_smooth'][:,inds]/1e3/((cm*TNTeq)**(1/3)), lw = 0.75, ls = '-', c='k')
        ax.set_xlabel('Angle of incidence (degrees)')
        ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
        ax.minorticks_on()
        ax.set_xlim(0,80)
        ax.set_ylim(0,6)
        ax.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
        ax.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
        plt.tight_layout()
    

    return fig0, fig2
fig0, fig2 = graph_dataset_overview(small)
fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\data_overview_small_a.pdf"), format = 'pdf')
fig2.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\data_overview_small_b_test.pdf"), format = 'pdf')
# fig3.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\data_overview_small_c.pdf"), format = 'pdf')

fig0, fig2 = graph_dataset_overview(large, 1)
fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\data_overview_large_a.pdf"), format = 'pdf')
fig2.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\data_overview_large_b_test.pdf"), format = 'pdf')
#.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\Graphs\data_overview_large_c.pdf"), format = 'pdf')

def plot_model_surfaces_RPB(dataset, eq_TNT):    
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, dataset['imp'].shape[0], 0)     
    
    run = []
    for i in dataset['so']:
        run.append(RPB_MCEER(np.linspace(0,80,200),i, cm*eq_TNT))

    i_surf = np.asarray(run).T
    i_surf = np.divide(i_surf, ((cm)**(1/3)))
    theta = np.repeat(np.linspace(0,80, dataset['imp'].shape[0])[:,np.newaxis], dataset['imp'].shape[1], 1) 
   
    
    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z, i_surf/1e3, levels = np.linspace(0,25,50), cmap = plt.cm.magma_r)
    cbar = fig.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,25,6))
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    ax.set_xlim(0,80)
    plt.tight_layout()
    
    fig2, ax = plt.subplots(1,1)
    fig2.set_size_inches(3, 2.5)
    diff = i_surf/1e3-(dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3)))
    mean_diff = np.mean(diff)
    CS = ax.contourf(theta, z, diff, levels = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 2),50), cmap = plt.cm.magma_r)
    cbar = fig2.colorbar(CS, format='%.0f' , ticks = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 2),5))  
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    ax.set_xlim(0,80)
    plt.tight_layout()
    return i_surf, mean_diff, fig, fig2
small['RPB_MCEER_surf_1_2'], small['RPB_MCEER_surf_1_2_md'], fig, fig2 = plot_model_surfaces_RPB(large, 1.2)
large['RPB_MCEER_surf_1_2'], large['RPB_MCEER_surf_1_2_md'], fig, fig2 = plot_model_surfaces_RPB(large, 1.2)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_RPB_MCEER.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_RPB_MCEER2.pdf', format = 'pdf')
large['RPB_MCEER_surf_1_15'], large['RPB_MCEER_surf_1_15_md'], fig, fig2 = plot_model_surfaces_RPB(large, 1.15)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_RPB_MCEER_15.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_RPB_MCEER2_15.pdf', format = 'pdf')

#------------------------------------------------------------------------------
#Model fitting Stuff that needs refinement 
#------------------------------------------------------------------------------

#1) One Gaussian
def gauss_curve(x, *params):
    y1 = np.zeros_like(x)

    y1 = params[1] * np.exp( -((x - params[0])**2 / (2*(params[2]**2)) ) )

    y = y1
    return y

#Objective function to be minimised. Loss function is MSE.
def lm_residual(params, x, ytrue):
    cen1 = params['cen1'].value
    amp1 = params['amp1'].value
    wid1 = params['wid1'].value

    args = [cen1, amp1, wid1]
    
    global current_cost
    current_cost = mean_squared_error(ytrue, gauss_curve(x, *args))  
    return current_cost
params = lm.Parameters()
params['cen1'] = lm.Parameter(name='cen1', value = 0.5, vary = 'false', min = 0.4, max = 0.6)
params['amp1'] = lm.Parameter(name='amp1', value = 0.5, min=0, max=1)
params['wid1'] = lm.Parameter(name='wid1', value = 0.5, min=0, max=1)   

#-----------------------------------------------------------------------------

#impulse distribution in theta -----------------------------------------------
def my_model_graphs_exact():
    #Fitting model
    data= np.concatenate([np.flipud(small['icr'].mean(1)), small['icr'].mean(1)])
    #data= np.concatenate([np.flipud(small['icr'].max(1)), small['icr'].max(1)])
    x = np.linspace(-80,80,len(data))
    x = (x - min(x)) / (max(x) - min(x))
    result = lm.minimize(lm_residual, params, method = 'least_squares', args = (x, data))
    gaussmod = gauss_curve(x, result.params['cen1'].value, result.params['amp1'].value, result.params['wid1'].value)      
    residual =  small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::]
    #Gaussian - 1 -------------------------------------------------------------
    fig, [ax0, ax1] = plt.subplots(1,2)
    fig.set_size_inches(4.6,2.5)    
    ax0.fill_between(np.linspace(0,80,200), small['icr'].min(1), small['icr'].max(1), color = 'grey', alpha = 0.4, label = 'CFD - range')  
    ax0.plot(np.linspace(0,80,200), small['icr'].mean(1), 'r', lw = 1, markevery=10, label = 'CFD - mean')
    ax0.plot(np.linspace(0,80,200), gaussmod[int(len(gaussmod)/2)::], 'k--', lw = 1.5, label = 'model')
    ax0.set_xlabel('Angle of incidence (degrees)')
    ax0.set_ylabel('Normalised peak specific impulse')
    ax0.set_xlim(0,80)
    ax0.set_ylim(0,1)
    handles, labels = ax0.get_legend_handles_labels()
    handles, labels = [handles[2], handles[0], handles[1]], [labels[2], labels[0], labels[1]]
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})    
    ax1.set_xlabel('Angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax1.plot(np.linspace(0,80,200), residual, ls = 'None', marker = 's', mfc = 'white', mec='k',  ms = 3., markevery = 12)
    ax1.set_ylim(-0.1, 0.1) 
    ax1.set_xlim(0,80)
    MAE = abs(residual).mean()
    if MAE < 0.0001:
        text_MAE = "$MAE < 0.0001$"
    else:
        text_MAE = "$MAE = {:.3f}$".format(MAE)   
    ax1.text(0.05,0.05, text_MAE, fontsize='x-small', transform=ax1.transAxes)
    RMSE = ((residual**2).mean())**0.5
    if RMSE < 0.0001:
        text_RMSE = "$RMSE < 0.0001$"
    else:
        text_RMSE = "$RMSE = {:.3f}$".format(RMSE)   
    ax1.text(0.05,0.15, text_RMSE, fontsize='x-small', transform=ax1.transAxes)
    #axis settings
    ax0.minorticks_on()
    ax0.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax0.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax1.minorticks_on()
    ax1.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax1.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)   
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\model_gaussian1.pdf', format = 'pdf')
    
   
    #Henrych ------------------------------------------------------------
    rem_actual = Henrych_i((0.08-charge_rad), charge_rad, 7900, 5.53, 1660, np.linspace(0,80,200))   
    residual = small['icr'].mean(1) - rem_actual/max(rem_actual)
    fig, [ax0, ax1] = plt.subplots(1,2)
    fig.set_size_inches(4.6,2.5)   
    ax0.fill_between(np.linspace(0,80,200), small['icr'].min(1), small['icr'].max(1), color = 'grey', alpha = 0.4, label = 'CFD - range')
    ax0.plot(np.linspace(0,80,200), small['icr'].mean(1), 'r', lw = 1, markevery=10, label = 'CFD - mean')
    #ax0.plot(np.linspace(0,80,80),np.cos(np.deg2rad(np.linspace(0,80,80)))**4) #checking the distribution      
    ax0.plot(np.linspace(0,80,num=200), rem_actual/max(rem_actual), 'k--', lw = 1.5, label = 'model')
    ax1.plot(np.linspace(0,80,200), residual, ls = 'None', marker = 's', mfc = 'white', mec='k',  ms = 3., markevery = 12)
    ax1.set_ylim(-0.1, 0.1)
    ax1.set_xlim(0,80)
    MAE = abs(residual).mean()
    if MAE < 0.0001:
        text_MAE = "$MAE < 0.0001$"
    else:
        text_MAE = "$MAE = {:.3f}$".format(MAE)   
    ax1.text(0.05,0.05, text_MAE, fontsize='x-small', transform=ax1.transAxes)
    RMSE = ((residual**2).mean())**0.5
    if RMSE < 0.0001:
        text_RMSE = "$RMSE < 0.0001$"
    else:
        text_RMSE = "$RMSE = {:.3f}$".format(RMSE)   
    ax1.text(0.05,0.15, text_RMSE, fontsize='x-small', transform=ax1.transAxes)
    ax0.set_xlabel('Angle of incidence (degrees)')
    ax0.set_ylabel('Normalised peak specific impulse')
    ax0.set_xlim(0,80)
    ax0.set_ylim(0,1)
    handles, labels = ax0.get_legend_handles_labels()
    handles, labels = [handles[2], handles[0], handles[1]], [labels[2], labels[0], labels[1]]
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})  
    ax1.set_xlabel('Angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.minorticks_on()
    ax0.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax0.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax1.minorticks_on()
    ax1.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax1.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)  
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\model_henrych.pdf', format = 'pdf')
    

    #RPB-MCEER ------------------------------------------------------------
    
    model = small['RPB_MCEER_surf_1_2']/small['RPB_MCEER_surf_1_2'].max(0)
    model = model.mean(1)
    residual =  small['icr'].mean(1) - model
    fig, [ax0, ax1] = plt.subplots(1,2)
    fig.set_size_inches(4.6,2.5)  
    ax0.fill_between(np.linspace(0,80,200), small['icr'].min(1), small['icr'].max(1), color = 'grey', alpha = 0.4, label = 'CFD - range')
    ax0.plot(np.linspace(0,80,200), small['icr'].mean(1), 'r', lw = 1, label = 'CFD - mean')       
    #ax0.plot(np.linspace(0,80,200), RPB_MCEER_exp_model_inter , 'k--', lw = 1.5, label = 'model')        
    ax0.plot(np.linspace(0,80,200),model , 'k--', lw = 1.5, label = 'model')
    ax1.plot(np.linspace(0,80,200), residual, ls = 'None', marker = 's', mfc = 'white', mec='k',  ms = 3., markevery = 12)
    ax1.set_ylim(-0.1, 0.1)
    ax1.set_xlim(0,80)
    MAE = abs(residual).mean()
    if MAE < 0.0001:
        text_MAE = "$MAE < 0.0001$"
    else:
        text_MAE = "$MAE = {:.3f}$".format(MAE)   
    ax1.text(0.05,0.05, text_MAE, fontsize='x-small', transform=ax1.transAxes)
    RMSE = ((residual**2).mean())**0.5
    if RMSE < 0.0001:
        text_RMSE = "$RMSE < 0.0001$"
    else:
        text_RMSE = "$RMSE = {:.3f}$".format(RMSE)   
    ax1.text(0.05,0.15, text_RMSE, fontsize='x-small', transform=ax1.transAxes)
    ax0.set_xlabel('Angle of incidence (degrees)')
    ax0.set_ylabel('Normalised peak specific impulse')
    ax0.set_xlim(0,80)
    ax0.set_ylim(0,1)
    handles, labels = ax0.get_legend_handles_labels()
    handles, labels = [handles[2], handles[0], handles[1]], [labels[2], labels[0], labels[1]]
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})  
    ax1.set_xlabel('Angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.minorticks_on()
    ax0.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax0.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax1.minorticks_on()
    ax1.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax1.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\model_RPB_MCEER.pdf', format = 'pdf')        
    return gaussmod
small['gaussmod'] = my_model_graphs_exact()



#impulse distribution in theta -----------------------------------------------
def my_model_graphs_large(): 
    data_o = large['icr'].mean(1)
    data = np.concatenate([np.flipud(data_o), data_o])
    x = np.linspace(-80,80,len(data))
    x = (x - min(x)) / (max(x) - min(x))       
    #Nonlinear regression -gaussians
    result = lm.minimize(lm_residual, params, method = 'least_squares', args = (x, data))
    gaussmod = gauss_curve(x, result.params['cen1'].value, result.params['amp1'].value, result.params['wid1'].value)
    residual = large['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::]

    fig, [ax0, ax1] = plt.subplots(1,2)
    fig.set_size_inches(4.6,2.5)    
    ax0.fill_between(np.linspace(0,80,200), large['icr'].min(1), large['icr'].max(1), color = 'grey', alpha = 0.4, label = 'CFD - range') 
    ax0.plot(np.linspace(0,80,200), data_o, 'r', lw = 1, markevery=10, label = 'CFD - mean')   
    ax0.plot(np.linspace(0,80,200), gaussmod[int(len(gaussmod)/2)::], 'k--', lw = 1.5, label = 'model')    
    ax1.plot(np.linspace(0,80,200), residual, ls = 'None', marker = 's', mfc = 'white', mec='k',  ms = 3., markevery = 12)
    ax0.set_xlim(0,80)
    ax0.set_ylim(0, 1)
    ax1.set_xlim(0,80)
    ax1.set_ylim(-0.1, 0.1)    
    ax1.set_ylim(-0.1, 0.1) 
    ax1.set_xlim(0,80)
    MAE = abs(residual).mean()
    if MAE < 0.0001:
        text_MAE = "$MAE < 0.0001$"
    else:
        text_MAE = "$MAE = {:.3f}$".format(MAE)   
    RMSE = ((residual**2).mean())**0.5
    if RMSE < 0.0001:
        text_RMSE = "$RMSE < 0.0001$"
    else:
        text_RMSE = "$RMSE = {:.3f}$".format(RMSE)   
    ax1.text(0.05,0.05, text_RMSE, fontsize='x-small', transform=ax1.transAxes)
    ax1.text(0.05,0.15, text_MAE, fontsize='x-small', transform=ax1.transAxes)  
    ax0.set_xlabel('Angle of incidence (degrees)')
    ax0.set_ylabel('Normalised peak specific impulse')
    handles, labels = ax0.get_legend_handles_labels()
    handles, labels = [handles[2], handles[0], handles[1]], [labels[2], labels[0], labels[1]]
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})  
    ax1.set_xlabel('Angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.minorticks_on()
    ax0.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax0.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax1.minorticks_on()
    ax1.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax1.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\model_gaussian1_largez.pdf', format = 'pdf')      
    return gaussmod
large['gaussmod'] = my_model_graphs_large()      

#Build surface from Guassian Eq and power law.
def plot_model_surfaces(dataset, issmall = None):
    theta = np.repeat(np.linspace(0,80, dataset['imp'].shape[0])[:,np.newaxis], dataset['imp'].shape[1], 1) 
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, dataset['imp'].shape[0], 0)    
    
    
    peak_i_mod = np.multiply(np.power(z, dataset['slope']), dataset['const'])    #scaledpeakimpulses
    theta_dist = dataset['gaussmod'][int(len(dataset['gaussmod'])/2)::]
    theta_dist = theta_dist.reshape((len(theta_dist), 1))
    theta_dist = np.repeat(theta_dist, peak_i_mod.shape[1], axis=1) 
    
    i_surf = np.multiply(theta_dist, peak_i_mod)

    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z, i_surf, levels = np.linspace(0,25,50), cmap = plt.cm.magma_r)
    cbar = fig.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,25,6))
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    if issmall is not None:
        ax.set_ylim(0.11,0.21)
    else:
        pass
    plt.tight_layout()
    
    fig2, ax = plt.subplots(1,1)
    fig2.set_size_inches(3, 2.5)
    diff = (dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3))) - i_surf
    mean_diff = np.mean(abs(diff))
    specific_impulse_residual = {'mean_diff':np.mean(abs(diff)), 'max_diff':np.max(abs(diff)), 'mean_impulse':np.mean(i_surf)}
    CS = ax.contourf(theta, z, diff, levels = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 1),50), cmap = plt.cm.magma_r)
    cbar = fig2.colorbar(CS, format='%.0f' , ticks = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 1),5))  
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    if issmall is not None:
        ax.set_ylim(0.11,0.21)
    else:
        pass
    plt.tight_layout()
    return i_surf, specific_impulse_residual, fig, fig2
small['gauss_surf'], small['gauss_surf_residual'], fig, fig2 = plot_model_surfaces(small, 1)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\smallz_gaussian1.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\smallz_gaussian2.pdf', format = 'pdf')
large['gauss_surf'], large['gauss_surf_residual'], fig, fig2 = plot_model_surfaces(large)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_gaussian1.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_gaussian2.pdf', format = 'pdf')

def plot_model_surfaces_Henrych(dataset):    
    theta = np.repeat(np.linspace(0,80, dataset['imp'].shape[0])[:,np.newaxis], dataset['imp'].shape[1], 1) 
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, dataset['imp'].shape[0], 0)    
    
    imp, theta_exp = [], []
    for i in dataset['so']:
        imp.append(Henrych_i(i, 0.0246, 7900, 5.53, 1660, np.linspace(0,80,200)))#specific impulse from centre of plate outwards     
        
    i_surf = np.asarray(imp).T
    i_surf = np.divide(i_surf/1e3, ((cm*TNTeq)**(1/3)))
    

    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z, i_surf, levels = np.linspace(0,40,50), cmap = plt.cm.magma_r)
    cbar = fig.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,40,5))
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    plt.tight_layout()
    
    fig2, ax = plt.subplots(1,1)
    fig2.set_size_inches(3, 2.5)
    diff = (dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3))) - i_surf
    mean_diff = diff.mean()
    CS = ax.contourf(theta, z, diff, levels = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 2),50), cmap = plt.cm.magma_r)
    cbar = fig2.colorbar(CS, format='%.0f' , ticks = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 2),5))  
    cbar.ax.set_ylabel('Scaled specific impulse '+r'$(MPa.ms/kg^{1/3}$)', fontsize = 'x-small')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Angle of incidence (degrees)')
    plt.tight_layout()
    return i_surf, mean_diff, fig, fig2
large['henrych_surf'], large['henrych_surf_diff'], fig, fig2 = plot_model_surfaces_Henrych(large)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_henrych.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_henrych2.pdf', format = 'pdf')
      

def TotalImpulseSurfaces(dataset):
    target_scaled_radius = 1
    max_target_length = target_scaled_radius * 0.1**(1/3)
    upper_theta = 60
    theta_lim = np.linspace(0,upper_theta,80)   
    R = np.divide(max_target_length, np.tan(np.deg2rad(upper_theta))) 
    theta_test = np.repeat(theta_lim.reshape(len(theta_lim),1), dataset['imp'].shape[1], 1)    
    target_rad = np.multiply(np.tan(np.deg2rad(theta_test)), R)   
    target_rad = np.divide(target_rad, ((cm*TNTeq)**(1/3)))#scaled target radius
        
    Imp_CFD = np.zeros_like(target_rad)
    Imp_gauss = np.zeros_like(Imp_CFD)
    for i in range(Imp_CFD.shape[0]):
        for j in range(Imp_CFD.shape[1]):       
            #Imp_CFD[i,j] = Impulse_CFD(dataset['imp_smooth'][:,j], R, theta_lim[i], np.linspace(0,80,200))
            #Imp_gauss[i,j] = Impulse_CFD(dataset['gauss_surf'][:,j]*1e3*((cm*TNTeq)**(1/3)), R, theta_lim[i], np.linspace(0,80,200))
            Imp_CFD[i,j] = TotalImpulseCalc(dataset['imp_smooth'][:,j], R, theta_lim[i], np.linspace(0,80,200))
            Imp_gauss[i,j] = TotalImpulseCalc(dataset['gauss_surf'][:,j]*1e3*((cm*TNTeq)**(1/3)), R, theta_lim[i], np.linspace(0,80,200))
    
    dataset['gauss_total_impulse'], dataset['CFD_total_impulse'] = Imp_gauss, Imp_CFD
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, len(target_rad), 0) 

    fig_CFD, ax = plt.subplots(1,1)
    fig_CFD.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, z, dataset['CFD_total_impulse']/1e3/0.1, levels = np.linspace(0,roundup((dataset['CFD_total_impulse']/1e3/0.1).max(), base = 10),50), cmap = plt.cm.magma_r)
    cbar = fig_CFD.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,roundup((dataset['CFD_total_impulse']/1e3/0.1).max(), base = 10),7))
    cbar.ax.set_ylabel('Total scaled impulse ' +  r'$(MN.ms/kg)$')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Scaled target radius '+r'$(m/kg^{1/3}$)')
    #ax.set_xlim(0,1)
    ax.xaxis.set_major_locator(LinearLocator(6)) 
    plt.tight_layout()
    
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, z, dataset['gauss_total_impulse']/1e3/0.1, levels = np.linspace(0,roundup((dataset['gauss_total_impulse']/1e3/0.1).max(), base = 10),50), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,roundup((dataset['gauss_total_impulse']/1e3/0.1).max(), base = 10),7))
    cbar.ax.set_ylabel('Total scaled impulse ' +  r'$(MN.ms/kg)$')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Scaled target radius '+r'$(m/kg^{1/3}$)')
    #ax.set_xlim(0,1)
    ax.xaxis.set_major_locator(LinearLocator(6)) 
    plt.tight_layout()
       
    
    fig_test2, ax = plt.subplots(1,1)
    fig_test2.set_size_inches(3, 2.5)
    diff = (dataset['CFD_total_impulse'] - dataset['gauss_total_impulse'])/1e3/0.1
    CS = ax.contourf(target_rad, z, diff, levels = np.linspace(rounddwn(diff.min(), base = 2),roundup(diff.max(), base = 2),50), cmap = plt.cm.magma_r)
    cbar = fig_test2.colorbar(CS, format='%.0f' , ticks = np.linspace(rounddwn(diff.min(), base = 2),roundup(diff.max(), base = 2),5))   
    cbar.ax.set_ylabel('Total scaled impulse ' +  r'$(MN.ms/kg)$')
    ax.set_ylabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)')
    ax.set_xlabel('Scaled target radius '+r'$(m/kg^{1/3}$)')
    #ax.set_xlim(0,1)
    ax.xaxis.set_major_locator(LinearLocator(6)) 
    # ax.yaxis.set_major_locator(LinearLocator(5))
    # ax.xaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    # ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    #ax.locator_params(axis = 'both',tight=True, nbins=5)
    plt.tight_layout()
    
    return Imp_CFD, Imp_gauss, fig_CFD, fig_test, fig_test2 
small['CFD_total_impulse'], small['gauss_total_impulse'], fig0, fig1, fig2 = TotalImpulseSurfaces(small)
fig0.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\smallz_totalimpulse_CFD.pdf', format = 'pdf')
fig1.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\smallz_totalimpulse_gauss.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\smallz_totalimpulse_gauss2.pdf', format = 'pdf')
large['CFD_total_impulse'], large['gauss_total_impulse'], fig0, fig1, fig2 = TotalImpulseSurfaces(large)
fig0.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_totalimpulse_CFD.pdf', format = 'pdf')
fig1.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_totalimpulse_gauss.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\largez_totalimpulse_gauss2.pdf', format = 'pdf')

def interpolate_totalI(dataset):
    target_scaled_radius = 1
    max_target_length = target_scaled_radius * 0.1**(1/3)
    upper_theta = 60
    theta_lim = np.linspace(0,upper_theta,80)   
    R = np.divide(max_target_length, np.tan(np.deg2rad(upper_theta))) 
    theta_test = np.repeat(theta_lim.reshape(len(theta_lim),1), dataset['imp'].shape[1], 1)    
    target_rad = np.multiply(np.tan(np.deg2rad(theta_test)), R)   
    target_rad = np.divide(target_rad, ((cm*TNTeq)**(1/3)))#scaled target radius    

    
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, len(target_rad), 0) 
    
    tr = target_rad.flatten('F')
    zf = z.flatten('F')
    
    xi = yi = np.linspace(0,1,500) 
    xi,yi =np.meshgrid(xi,yi)#yi is scaled distance, xi is target radius
    
    
    trs = [np.where(xi > 0.1)[1][0], np.where(xi > 0.25)[1][0], np.where(xi > 0.75)[1][0], np.where(xi == 1)[1][0]]
    zs  = [np.where(yi > 0.11)[0][0], np.where(yi > 0.2)[0][0], np.where(yi > 0.3)[0][0], np.where(yi > 0.4)[0][0], np.where(yi > 0.5)[0][0]]
    vals = dataset['CFD_total_impulse']/1e3/0.1
    vals=vals.flatten('F')
    zi = griddata((tr, zf), vals, (xi,yi), method = 'cubic')
        
    z01 = zi[zs[0], trs[0]], zi[zs[0], trs[1]], zi[zs[0], trs[2]], zi[zs[0], trs[3]]
    z02 = zi[zs[1], trs[0]], zi[zs[1], trs[1]], zi[zs[1], trs[2]], zi[zs[1], trs[3]]
    z03 = zi[zs[2], trs[0]], zi[zs[2], trs[1]], zi[zs[2], trs[2]], zi[zs[2], trs[3]]
    z04 = zi[zs[3], trs[0]], zi[zs[3], trs[1]], zi[zs[3], trs[2]], zi[zs[3], trs[3]]
    z05 = zi[zs[4], trs[0]], zi[zs[4], trs[1]], zi[zs[4], trs[2]], zi[zs[4], trs[3]]
    I_CFD = [z01, z02, z03, z04, z05]
    
    vals = dataset['gauss_total_impulse']/1e3/0.1
    vals=vals.flatten('F')
    zi = griddata((tr, zf), vals, (xi,yi), method = 'cubic')
    
    z01 = zi[zs[0], trs[0]], zi[zs[0], trs[1]], zi[zs[0], trs[2]], zi[zs[0], trs[3]]
    z02 = zi[zs[1], trs[0]], zi[zs[1], trs[1]], zi[zs[1], trs[2]], zi[zs[1], trs[3]]
    z03 = zi[zs[2], trs[0]], zi[zs[2], trs[1]], zi[zs[2], trs[2]], zi[zs[2], trs[3]]
    z04 = zi[zs[3], trs[0]], zi[zs[3], trs[1]], zi[zs[3], trs[2]], zi[zs[3], trs[3]]
    z05 = zi[zs[4], trs[0]], zi[zs[4], trs[1]], zi[zs[4], trs[2]], zi[zs[4], trs[3]]
    I_gauss = [z01, z02, z03, z04, z05]    
    
    return I_CFD, I_gauss
large_CFD, large_gauss = interpolate_totalI(large)
small_CFD, small_gauss = interpolate_totalI(small)
change_small = np.around(np.divide((np.asarray(small_gauss) - np.asarray(small_CFD)) , np.asarray(small_CFD)) * 100, 0)
change_large = np.around(np.divide((np.asarray(large_gauss) - np.asarray(large_CFD)) , np.asarray(large_CFD)) * 100, 0)


 
def validationgraphs():
    val_highZ = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\250kg\res5", 250,TNTeq, sav=151)
    val_lowZ = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\5kg\res4", 5,TNTeq, sav=151)
    
    theta = np.linspace(0,80,200)
    
    #Radial ordinate calcs ----------------------------------------------------
    radial_ord_lowZ = [0,0.0625, 0.125, 0.1875, 0.250, 0.375, 0.500]
    theta_ord_lowZ = np.rad2deg(np.arctan(np.divide(radial_ord_lowZ, val_lowZ['so'])))
    lowZi_eq5 = ( (5)**(1/3) * 
                 (val_lowZ['z'][0]**-1.858) * 0.383 *
                 np.exp(-(theta_ord_lowZ/160)**2 / (2*0.189**2)) ).reshape((7,1))
    lowZi_eq6 = ( (5)**(1/3) * 
                 (val_lowZ['z'][0]**-1.663) * 0.557 *
                 np.exp(-(theta_ord_lowZ/160)**2 / (2*0.198**2)) ).reshape((7,1))
    
    radial_ord_highZ = [0,0.625, 1.25, 1.875, 2.250]
    theta_ord_highZ = np.rad2deg(np.arctan(np.divide(radial_ord_highZ, val_highZ['so'])))  

    highZi_eq6 = ( (250)**(1/3) * 
                  (val_highZ['z'][0]**-1.663) * 0.557 *
                  np.exp(-(theta_ord_highZ/160)**2 / (2*0.198**2)) ).reshape((5,1))
    
    CFD_250kg = np.asarray([val_highZ['imp_smooth'][np.where(theta > i)[0][0]] for i in theta_ord_highZ])/1e3
    CFD_250kg_pc = ((highZi_eq6 - CFD_250kg)/CFD_250kg)*100
    CFD_5kg = np.asarray([val_lowZ['imp_smooth'][np.where(theta > i)[0][0]] for i in theta_ord_lowZ])/1e3
    CFD_5kg_pc1 = ((lowZi_eq5 - CFD_5kg)/CFD_5kg)*100
    CFD_5kg_pc2 = ((lowZi_eq6 - CFD_5kg)/CFD_5kg)*100
    #--------------------------------------------------------------------------

    
    
    lowz = ( (5)**(1/3) * 
            (val_lowZ['z'][0]**-1.858) * 0.383 *
            np.exp(-(theta/160)**2 / (2*0.189**2)) )
    
    highz = ( (250)**(1/3) * 
            (val_highZ['z'][0]**-1.663) * 0.557 *
            np.exp(-(theta/160)**2 / (2*0.198**2)) )
    
    
    x1 = np.tan(np.deg2rad(np.linspace(0,80,200))) * val_lowZ['so']
    fig, ax1 = plt.subplots(1,1)
    fig.set_size_inches(2.5, 2.5) 
    ax1.plot(x1, val_lowZ['imp_smooth']/1e3, 'r', ls = '-', lw = 1, label = 'CFD')
    ax1.plot(x1, lowz, 'k--', lw = 1.5,label = 'prediction')
    handles, labels = ax1.get_legend_handles_labels()
    ax1.legend(handles, labels, loc='upper right', prop={'size':6})
    
    ax1.set_xlabel('Distance from centre (m)')
    ax1.set_ylabel('Peak specific impulse '+r'$(MPa.ms$)', fontsize = 'small')
    ax1.set_xlim(0,0.25)
    ax1.set_ylim(0,20)
    ax1.minorticks_on()
    ax1.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax1.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    ax1.locator_params(axis = 'both',tight=True, nbins=5)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\lowz_val.pdf', format = 'pdf')
 
    x2 = np.tan(np.deg2rad(np.linspace(0,80,200))) * val_highZ['so']
    fig, ax2 = plt.subplots(1,1)
    fig.set_size_inches(2.5, 2.5)    
    ax2.plot(x2, val_highZ['imp_smooth']/1e3, 'r', ls = '-', lw = 1.0, label = 'CFD')
    ax2.plot(x2, highz, 'k--', lw = 1.5)
    
    ax2.set_xlabel('Distance from centre (m)')
    ax2.set_ylabel('Peak specific impulse '+r'$(MPa.ms$)', fontsize = 'small')
    ax2.set_xlim(0,2.5)
    ax2.set_ylim(0,20)
    ax2.minorticks_on()
    ax2.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax2.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    plt.tight_layout()
    ax2.locator_params(axis = 'both',tight=True, nbins=5)
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\highz_val.pdf', format = 'pdf')


    # data5kg = pre.FileAddressList(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\5kg\res2"+ r"\*gauges", 1)
    # data250kg = pre.FileAddressList(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\250kg\res5"+ r"\*gauges", 1)
    
    # fig00, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2,2)
    # #theta = 0
    # ax1.plot(data5kg[0][:,0],data5kg[0][:,1]) #OP
    # ax1.set_xlim(0,0.003)
    # ax2.plot(data5kg[0][:,0],data5kg[0][:,201])#imp
    # ax2.set_xlim(0,0.003)
    # #theta = 80
    # ax3.plot(data5kg[0][:,0],data5kg[0][:,200])#OP
    # ax3.set_xlim(0,0.003)
    # ax4.plot(data5kg[0][:,0],data5kg[0][:,400])#imp
    # ax4.set_xlim(0,0.003)
    
    # fig00, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2,2)
    # #theta = 0
    # ax1.plot(data250kg[0][:,0],data250kg[0][:,1]) #OP
    # ax1.set_xlim(0,0.03)
    # ax2.plot(data250kg[0][:,0],data250kg[0][:,201])#imp
    # ax2.set_xlim(0,0.03)
    # #theta = 80
    # ax3.plot(data250kg[0][:,0],data250kg[0][:,200])#OP
    # ax3.set_xlim(0,0.03)
    # ax4.plot(data250kg[0][:,0],data250kg[0][:,400])#imp
    # ax4.set_xlim(0,0.03)  
validationgraphs()

def impulse_validation():
    dataGer = np.genfromtxt(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\_SER comments and other literature\Geretto_data.csv"), delimiter =',')
    data = sio.loadmat(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper1\_SER comments and other literature\imp_predictor.mat") )    
    
    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(5, 3)
    ax.plot(data['Z'].T, data['totimp']*1000, 'k--', lw= 1.5, label = 'Prediction')
    ax.scatter(dataGer[:,4], dataGer[:,5], marker="x", s=10., color='grey', edgecolors='none', label = 'Exp.')  
    ax.scatter(data['ZGer'], data['meanGer'], marker="o", s=10., edgecolors='k', label = 'Exp. mean')  
    ax.set_xlabel('Scaled distance, Z ' + r'$(m/kg^{1/3}$)', fontsize = 'small')
    ax.set_ylabel('Area-integrated impulse ' + r'$(N.s)$')
    ax.set_xlim(0.2,0.5)
    ax.set_ylim(0,60)
    ax.minorticks_on()
    ax.grid(which='minor', ls=':', dashes=(1,5,1,5), color = [0.1, 0.1, 0.1], alpha=0.25)
    ax.grid(which='major', ls = '-', color = [0.15, 0.15, 0.15], alpha=0.15)
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles, labels, loc='upper right', prop={'size':6})
    ax.locator_params(axis = 'both',tight=True, nbins=5)    
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper1\Graphs\geretto_val.pdf', format = 'pdf')
impulse_validation()
