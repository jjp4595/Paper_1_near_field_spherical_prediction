"""
Peak impulse predictor for theta. 
"""

import preamble_functions as pre
import matplotlib.pyplot as plt #3.0.2
from matplotlib.lines import Line2D
from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter
from scipy.signal import savgol_filter
import math
import numpy as np #1.15.4

import scipy.io as sio
import lmfit as lm
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import os
from scipy import stats
from impulse_models import *
from scipy.optimize import minimize

#plt.rcParams["font.family"] = "cmr10" #Set Graph fonts to cmr10
params = {'font.family':'serif',
        'axes.labelsize':'small',
        'xtick.labelsize':'x-small',
        'ytick.labelsize':'x-small',
#        
        'lines.markersize': 10,
        'scatter.marker': 's',
#        
        'legend.fontsize':'small',
        'legend.title_fontsize':'small',
        'legend.fancybox': True,
        'legend.framealpha': 0.5,
        'legend.shadow': False,
        'legend.frameon': True,
#        
#
        'grid.linestyle':'--',
        'grid.linewidth':'0.5',
        'lines.linewidth':'0.5'}

plt.rcParams.update(params)



def roundup(x, base=10):
    return int(base * math.ceil(x/base)) 
def rounddwn(x, base=10):
    return int(base * math.floor(x/base))


#Some charge properties
charge_rad = 0.0246
cm = 0.1
TNTeq = 1

#-----------------------------------------------------------------------------

def dataimport(folderpath, cm, TNTeq, sav=151):
    file = pre.FileAddressList(folderpath + r"\*.txt")
    data = pre.FileAddressList(folderpath+ r"\*gtable", 1)
    data = np.asarray([data[i][:,7] for i in range(len(file))]).T 
    smooth = np.asarray([savgol_filter(data[:,i], sav, 3) for i in range(len(file))]).T
    smooth_Icr = np.asarray([smooth[:,i]/ (max(smooth[:,i])) for i in range(len(file))]).T     
    z_center = [(pre.standoff_func(file[i]))/((cm*TNTeq)**(1/3)) for i in range(len(file))]
    z_clear = [(pre.standoff_func(file[i]) - charge_rad)/((cm*TNTeq)**(1/3)) for i in range(len(file))]
    z_center = np.asarray(z_center)
    z_clear = np.asarray(z_clear)
    so = (np.asarray(z_center) * ((cm*TNTeq)**(1/3)))    
    so_clear = (np.asarray(z_clear) *((cm*TNTeq)**(1/3)))  
    keys = ['imp', 'imp_smooth', 'icr', 'z', 'z_clear', 'so', 'so_clear']
    vals = [data, smooth, smooth_Icr, z_center, z_clear, so, so_clear]
    d = dict(zip(keys, vals))
    return d
small = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z055_16_latest\1500mm_ZL100mm_res5", cm, TNTeq)
test = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\testing_z_range", cm, TNTeq)
large = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\main_z16_5", cm, TNTeq)

#-----------------------------------------------------------------------------
def import_exp():
    gtable_80mm = pre.FileAddressList(os.path.join(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Near Field Sims\Sims\Latest\80mm_with_afterburn\*gtable"),1)
    theta_80mm_mesh = np.rad2deg(np.arctan(gtable_80mm[0][:,2]/0.08))
    return gtable_80mm, theta_80mm_mesh
gtable_80mm, theta_80mm_mesh = import_exp()
def overlay_exps(ax, is_crit = None):
    #Load Data for 80mm and 380mm Apollo Experimental ------------------------
    NF_80mm_exp = sio.loadmat(os.path.join(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Near Field Sims\100gPE4Sphere_80mm") )

    coords = np.append(np.arange(-100,101,25), np.arange(-100,-24,25)) 
    coords = np.append(coords, np.arange(25,101,25))
    coords = np.divide(coords,1000)
    coords_mean = np.arange(0,0.101,0.025)
    theta_exp_80mm = np.rad2deg(np.arctan(np.abs(coords)/0.08))
    theta_exp_80mm_mean = np.rad2deg(np.arctan(np.abs(coords_mean)/0.08))
    MxI_1_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,0])
    MxI_2_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,1])
    MxI_3_80mm = np.transpose(NF_80mm_exp['MxI'][:,:,2])
    Mx_mean_80mm = np.transpose(NF_80mm_exp['MEANI'])
    if is_crit is None:
        ax.scatter(theta_exp_80mm, MxI_1_80mm/1e3, marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none', label = 'Exp')
        ax.scatter(theta_exp_80mm, MxI_2_80mm/1e3, marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm, MxI_3_80mm/1e3, marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm_mean, Mx_mean_80mm/1e3, marker="o", s=15., label = 'Exp - mean')
    else:
        ax.scatter(theta_exp_80mm, np.divide(MxI_1_80mm, max(MxI_1_80mm)), marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none', label = 'Exp')
        ax.scatter(theta_exp_80mm, np.divide(MxI_2_80mm, max(MxI_2_80mm)), marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm, np.divide(MxI_3_80mm, max(MxI_3_80mm)), marker="x", s=15., color=[0.75,0.75,0.75], edgecolors='none')
        ax.scatter(theta_exp_80mm_mean, np.divide(Mx_mean_80mm, max(Mx_mean_80mm)), marker="o", s=15., label = 'Exp - mean')
#------------------------------------------------------------------------------    



#Graph 2 Power law-------------------------------------------------------------
def graph_powerlaw(dataset):    
    slope, intercept, r_value, p_value, std_err = stats.linregress(np.log10(dataset['z']), np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))))
    linear_model = intercept + slope*np.log10(dataset['z'])
    const = np.divide(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3)), dataset['z']**slope)
    const = const.sum()/len(const)
    residuals_power = np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))) - linear_model
    RSS_power = np.power(residuals_power,2).sum()
    RSE_power = ( (1/(len(residuals_power)-2)) * RSS_power   )#Residual standard error https://stats.stackexchange.com/questions/57746/what-is-residual-standard-error
    text_ax1 = "$R^2 =$" + str(round(r2_score(np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))), linear_model), 3))
    
    if p_value < 0.0001:
        text_ax3_p = "$p < 0.0001$"
    else:
        text_ax3_p = "$p = {:.3f}$".format(p_value)
    
    if RSE_power < 0.0001:
        text_ax3_se = "$RSE < 0.0001$"
    else:
        text_ax3_se = "$RSE = {:.3f}$".format(RSE_power)
    
    
    text_ax2 = "$f(x) = {%.3f}.x^{%.3f}$" % (const, slope)
     
    fig1, [ax1, ax3, ax2] = plt.subplots(1,3)
    fig1.set_size_inches(7, 2.5)
    
    ax1.scatter(np.log10(dataset['z']), np.log10(dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3))), marker = 's',facecolors = 'none', edgecolors='k', s = 10., label = 'CFD data')
    ax1.plot(np.log10(dataset['z']), linear_model, 'k', label='fitted model')
    #ax1.plot(np.log10(dataset['z']), linear_model + (2 * RSE_power), '--k', alpha = 0.2, label='95% PI')
    ax1.plot(np.log10(dataset['z']), linear_model - (2 * RSE_power), '--k', alpha = 0.2)
    ax1.text(0.1, 0.25, text_ax1, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.text(0.1, 0.15, text_ax3_p, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.text(0.1, 0.05, text_ax3_se, fontsize = 'x-small', transform=ax1.transAxes)
    ax1.set_ylabel('log(peak scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', wrap = True, fontsize = 'x-small')
    ax1.set_xlabel('log(z ' + r'$(m.kg^{\frac{1}{3}})$' +')')
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    

    ax2.scatter(dataset['z'], dataset['imp_smooth'].max(0)/1e3/((cm*TNTeq)**(1/3)), marker = 's',facecolors = 'none', edgecolors='k', s = 10., label = 'CFD data')
    ax2.plot(dataset['z'], const * dataset['z']**slope, 'k', label='fitted model')
    ax2.text(0.25, 0.9, text_ax2, fontsize = 'small', transform=ax2.transAxes)
    ax2.set_ylabel('peak scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', wrap = True, fontsize = 'x-small')
    ax2.set_xlabel('z ' + r'$(m/kg^{\frac{1}{3}})$')
    ax2.minorticks_on()
    ax2.set_ylim(0,25)
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5)
    
    ax3.scatter(np.log10(dataset['z']), residuals_power,marker = 's',facecolors = 'none', edgecolors='k',  s = 10., label = 'Residuals')
    ax3.set_ylim(-0.1,0.1)
    ax3.set_ylabel('Residual')
    ax3.set_xlabel('log(z ' + r'$(m/kg^{\frac{1}{3}})$' +')')
    ax3.minorticks_on()
    ax3.grid(which='minor', alpha=0.2)
    ax3.grid(which='major', alpha=0.5)
    
    handles, labels = ax1.get_legend_handles_labels()
    ax1.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    ax2.locator_params(axis = 'both',tight=True, nbins=6)
    ax3.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    return fig1, slope, const
fig_power, small['slope'], small['const'] = graph_powerlaw(small)
fig_power.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\power_fit_small.pdf"), format = 'pdf')
fig_power, large['slope'], large['const'] = graph_powerlaw(large)
fig_power.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\power_fit_large.pdf"), format = 'pdf')
#fig_power, test['slope'], test['const'] = graph_powerlaw(test)
#-----------------------------------------------------------------------------

#Graph1 - dataset- overview ---------------------------------------------------
def graph_dataset_overview(dataset, reduced=None):  

    theta = np.repeat(np.linspace(0,80, dataset['imp'].shape[0])[:,np.newaxis], dataset['imp'].shape[1], 1) 
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, dataset['imp'].shape[0], 0)
    

    fig0, ax = plt.subplots(1,1)
    fig0.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z,dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3)), levels = np.linspace(0,25,50), cmap = plt.cm.magma_r)
    cbar = fig0.colorbar(CS, format='%.1f' ,ticks = np.linspace(0,25,6))
    # ax.xaxis.set_major_locator(LinearLocator(5)) 
    # ax.yaxis.set_major_locator(LinearLocator(5))
    # ax.xaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    # ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    cbar.ax.set_ylabel('scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', fontsize = 'x-small')
    ax.set_ylabel('scaled distance, z ' + r'$(m/kg^{\frac{1}{3}}$)')
    ax.set_xlabel('incident wave angle (degrees)')
    
    plt.tight_layout()

    fig3, ax = plt.subplots(1,1)
    fig3.set_size_inches(2.5, 2.5)
    ax.plot(theta, dataset['icr'], lw = 0.5, ls = '-', c='k')
    ax.set_xlabel('incident wave angle (degrees)')
    ax.set_ylabel('peak specific impulse ratio')
    ax.minorticks_on()
    ax.set_xlim(0,80)
    ax.set_ylim(0,1)
    ax.grid(which='minor', alpha=0.2)
    ax.grid(which='major', alpha=0.5)
    plt.tight_layout()
    
    if reduced == None:
        fig2, ax = plt.subplots(1,1)
        fig2.set_size_inches(2.5, 2.5)
        ax.plot(theta, dataset['imp']/1e3/((cm*TNTeq)**(1/3)), lw = 0.5, ls = '--', c='r')
        ax.plot(theta, dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3)), lw = 0.75, ls = '-', c='k')
        ax.set_xlabel('incident wave angle (degrees)')
        ax.set_ylabel('scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', fontsize = 'x-small')
        labels = ['Smooth', 'Original']
        colors = ['k', 'r']
        lws = [0.75, 0.75]
        alphas = [1, 0.4]
        lss = ['-', '--']
        lines = [Line2D([0], [0],  lw=lws[i], ls = lss[i], alpha = alphas[i], color=colors[i]) for i in range(len(labels))]
        ax.legend(lines,labels, loc='upper right', prop={'size':6})
        ax.minorticks_on()
        ax.set_xlim(0,80)
        ax.set_ylim(0,roundup(dataset['imp'].max()/1e3/((cm*TNTeq)**(1/3)), base = 5))
        ax.grid(which='minor', alpha=0.2)
        ax.grid(which='major', alpha=0.5)
        plt.tight_layout()
    else:
        fig2, ax = plt.subplots(1,1)
        fig2.set_size_inches(2.5, 2.5)
        ax.plot(theta[:,4::], dataset['imp'][:,4::]/1e3/((cm*TNTeq)**(1/3)), lw = 0.5, ls = '--', c='r')
        ax.plot(theta[:,4::], dataset['imp_smooth'][:,4::]/1e3/((cm*TNTeq)**(1/3)), lw = 0.75, ls = '-', c='k')
        ax.set_xlabel('incident wave angle (degrees)')
        ax.set_ylabel('scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', fontsize = 'x-small')
        labels = ['Smooth', 'Original']
        colors = ['k', 'r']
        lws = [0.75, 0.75]
        alphas = [1, 0.4]
        lss = ['-', '--']
        lines = [Line2D([0], [0],  lw=lws[i], ls = lss[i], alpha = alphas[i], color=colors[i]) for i in range(len(labels))]
        ax.legend(lines,labels, loc='upper right', prop={'size':6})
        ax.minorticks_on()
        ax.set_xlim(0,80)
        ax.set_ylim(0,roundup(dataset['imp'][:,4::].max()/1e3/((cm*TNTeq)**(1/3)), base = 5))
        ax.grid(which='minor', alpha=0.2)
        ax.grid(which='major', alpha=0.5)
        plt.tight_layout()
    

    return fig0, fig2, fig3 
fig0, fig2, fig3 = graph_dataset_overview(small)
fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_small_a.pdf"), format = 'pdf')
fig2.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_small_b.pdf"), format = 'pdf')
fig3.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_small_c.pdf"), format = 'pdf')

fig0, fig2, fig3 = graph_dataset_overview(large, 1)
fig0.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_large_a.pdf"), format = 'pdf')
fig2.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_large_b.pdf"), format = 'pdf')
fig3.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\data_overview_large_c.pdf"), format = 'pdf')



#------------------------------------------------------------------------------
#Model fitting Stuff that needs refinement 
#------------------------------------------------------------------------------

#1) One Gaussian
def gauss_curve(x, *params):
    y1 = np.zeros_like(x)

    y1 = params[1] * np.exp( -((x - params[0])**2 / (2*(params[2]**2)) ) )

    y = y1
    return y

#Objective function to be minimised. Loss function is MSE.
def lm_residual(params, x, ytrue):
    cen1 = params['cen1'].value
    amp1 = params['amp1'].value
    wid1 = params['wid1'].value

    args = [cen1, amp1, wid1]
    
    global current_cost
    current_cost = mean_squared_error(ytrue, gauss_curve(x, *args))  
    return current_cost
params = lm.Parameters()
params['cen1'] = lm.Parameter(name='cen1', value = 0.5, vary = 'false', min = 0.4, max = 0.6)
params['amp1'] = lm.Parameter(name='amp1', value = 0.5, min=0, max=1)
params['wid1'] = lm.Parameter(name='wid1', value = 0.5, min=0, max=1)   

#Amplitude penalty function
def pen1(param1, param2):
    delta = param2 - param1
    out = max(0,delta)
    return out**0.5  

#-----------------------------------------------------------------------------

#impulse distribution in theta -----------------------------------------------
def my_model_graphs_exact():
    #Fitting model
    data= np.concatenate([np.flipud(small['icr'].mean(1)), small['icr'].mean(1)])
 
    x = np.linspace(-80,80,len(data))
    x = (x - min(x)) / (max(x) - min(x))
    result = lm.minimize(lm_residual, params, method = 'least_squares', args = (x, data))
    gaussmod = gauss_curve(x, result.params['cen1'].value, result.params['amp1'].value, result.params['wid1'].value)      
    
    #Gaussian - 1 -------------------------------------------------------------
    fig, [ax0, ax1, ax2] = plt.subplots(1,3)
    fig.set_size_inches(7,2.5)    
    ax0.plot(np.linspace(0,80,200), small['icr'].mean(1), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(np.linspace(0,80,200), small['icr'].min(1), small['icr'].max(1), color = 'silver', alpha = 0.4, label = 'CFD - range')       
    ax0.plot(np.linspace(0,80,200), gaussmod[int(len(gaussmod)/2)::], 'r--', lw = 1.5, label = 'model')
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('peak specific impulse ratio')
    ax0.set_xlim(0,80)
    ax0.set_ylim(0,1)
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})    
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    #text_gaussian1 = r"$f(\theta) = exp \left( \frac{-\left( \frac{\theta}{160} \right) ^2}{2 \times {%.3f}^2} \right)$" % (result.params['wid1'].value)    
    #ax1.text(0.05, 0.2, text_gaussian1, fontsize = 'small', transform=ax1.transAxes)       
    ax1.plot(np.linspace(0,80,200), small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::], ls = 'None', marker = 's', mfc = 'none', mec='k',  ms = 3., markevery = 8)
    ax1.set_ylim(-0.1, 0.1) 
    ax1.set_xlim(0,80)
    RSS = np.power(small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::],2).sum()
    RSE = ( (1/(len(small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::])-2)) * RSS  )
    if RSE < 0.0001:
        text_RSE = "$RSE < 0.0001$"
    else:
        text_RSE = "$RSE = {:.3f}$".format(RSE)   
    ax1.text(0.05,0.05, text_RSE, fontsize='x-small', transform=ax1.transAxes)
    res1 = stats.probplot(small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::], plot=ax2)   
    ax2.text(0.55, 0.25, r"$R^2 = $"+str(round(res1[1][2]**2, 3)), fontsize = 'x-small', transform=ax2.transAxes)
    ax2.get_lines()[0].set_marker('s')
    ax2.get_lines()[0].set_markerfacecolor('none')
    ax2.get_lines()[0].set_markeredgecolor('k')
    ax2.get_lines()[0].set_markersize(3.)
    ax2.get_lines()[0].set_markevery(6)       
    ax2.set_title("")
    ax2.set_xlim(-2.5,2.5)
    ax2.set_ylim(-0.05, 0.1)
    #axis settings
    ax0.minorticks_on()
    ax0.grid(which='minor', alpha=0.2)
    ax0.grid(which='major', alpha=0.5)
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    ax2.minorticks_on()
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5)    
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_gaussian1.pdf', format = 'pdf')
    
   
    #Henrych ------------------------------------------------------------
    rem_actual = Henrych_i((0.08-charge_rad), charge_rad, 7900, 5.53, 1660, np.linspace(0,80,200))   
    fig, [ax0, ax1, ax2] = plt.subplots(1,3)
    fig.set_size_inches(7,2.5)   
    ax0.plot(np.linspace(0,80,200), small['icr'].mean(1), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(np.linspace(0,80,200), small['icr'].min(1), small['icr'].max(1), color = 'silver', alpha = 0.4, label = 'CFD - range')       
    ax0.plot(np.linspace(0,80,num=200), rem_actual/max(rem_actual), 'r--', lw = 1.5, label = 'model')
    ax1.plot(np.linspace(0,80,200), small['icr'].mean(1) - rem_actual/max(rem_actual), ls = 'None', marker = 's', mfc = 'none', mec='k',  ms = 3., markevery = 8)
    ax1.set_ylim(-0.1, 0.1)
    ax1.set_xlim(0,80)
    RSS = np.power(small['icr'].mean(1) - rem_actual/max(rem_actual), 2).sum()
    RSE = ( (1/(len(small['icr'].mean(1) - rem_actual/max(rem_actual))-2)) * RSS  )
    if RSE < 0.0001:
        text_RSE = "$RSE < 0.0001$"
    else:
        text_RSE = "$RSE = {:.3f}$".format(RSE)   
    ax1.text(0.05,0.05, text_RSE, fontsize='x-small', transform=ax1.transAxes)
    res1 = stats.probplot(small['icr'].mean(1) - rem_actual/max(rem_actual), plot=ax2)   
    ax2.text(0.55, 0.25, r"$R^2 = $"+str(round(res1[1][2]**2, 3)), fontsize = 'x-small', transform=ax2.transAxes)
    ax2.get_lines()[0].set_marker('s')
    ax2.get_lines()[0].set_markerfacecolor('none')
    ax2.get_lines()[0].set_markeredgecolor('k')
    ax2.get_lines()[0].set_markersize(3.)
    ax2.get_lines()[0].set_markevery(6)     
    ax2.set_title("")
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('peak specific impulse ratio')
    ax0.set_xlim(0,80)
    ax0.set_ylim(0,1)
    ax2.set_xlim(-2.5,2.5)
    ax2.set_ylim(-0.05, 0.1)
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.minorticks_on()
    ax0.grid(which='minor', alpha=0.2)
    ax0.grid(which='major', alpha=0.5)
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    ax2.minorticks_on()
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5)      
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_henrych.pdf', format = 'pdf')
    

    #RPB-MCEER ------------------------------------------------------------
    RPB_MCEER_exp = RPB_MCEER_i(0.1*1.2, 0.08-charge_rad, 80)
    RPB_MCEER_exp_model_inter = np.interp(np.linspace(0,80,200), RPB_MCEER_exp[2][200,200::], RPB_MCEER_exp[3][200,200::] / max(RPB_MCEER_exp[3][200,200::]))
    fig, [ax0, ax1, ax2] = plt.subplots(1,3)
    fig.set_size_inches(7,2.5)   
    ax0.plot(np.linspace(0,80,200), small['icr'].mean(1), 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(np.linspace(0,80,200), small['icr'].min(1), small['icr'].max(1), color = 'silver', alpha = 0.4, label = 'CFD - range')       
    ax0.plot(np.linspace(0,80,200), RPB_MCEER_exp_model_inter , 'r--', lw = 1.5, label = 'model')        
    ax1.plot(np.linspace(0,80,200), small['icr'].mean(1) - RPB_MCEER_exp_model_inter, ls = 'None', marker = 's', mfc = 'none', mec='k',  ms = 3., markevery = 8)
    ax1.set_ylim(-0.1, 0.1)
    ax1.set_xlim(0,80)
    RSS = np.power(small['icr'].mean(1) - RPB_MCEER_exp_model_inter,2).sum()
    RSE = ( (1/(len(small['icr'].mean(1) - RPB_MCEER_exp_model_inter)-2)) * RSS  )
    if RSE < 0.0001:
        text_RSE = "$RSE < 0.0001$"
    else:
        text_RSE = "$RSE = {:.3f}$".format(RSE)   
    ax1.text(0.05,0.05, text_RSE, fontsize='x-small', transform=ax1.transAxes)
    res1 = stats.probplot(small['icr'].mean(1) - RPB_MCEER_exp_model_inter, plot=ax2)  
    
    ax2.text(0.55, 0.25, r"$R^2 = $"+str(round(res1[1][2]**2, 3)), fontsize = 'x-small', transform=ax2.transAxes)
    ax2.get_lines()[0].set_marker('s')
    ax2.get_lines()[0].set_markerfacecolor('none')
    ax2.get_lines()[0].set_markeredgecolor('k')
    ax2.get_lines()[0].set_markersize(3.)
    ax2.get_lines()[0].set_markevery(6)     
    ax2.set_title("")
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('peak specific impulse ratio')
    ax0.set_xlim(0,80)
    ax0.set_ylim(0,1)
    ax2.set_xlim(-2.5,2.5)
    ax2.set_ylim(-0.05, 0.1)
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.minorticks_on()
    ax0.grid(which='minor', alpha=0.2)
    ax0.grid(which='major', alpha=0.5)
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    ax2.minorticks_on()
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5) 
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_RPB_MCEER.pdf', format = 'pdf')        
    return gaussmod
small['gaussmod'] = my_model_graphs_exact()



#impulse distribution in theta -----------------------------------------------
def my_model_graphs_large(): 
    data_o = large['icr'].mean(1)
    data = np.concatenate([np.flipud(data_o), data_o])
    x = np.linspace(-80,80,len(data))
    x = (x - min(x)) / (max(x) - min(x))       
    #Nonlinear regression -gaussians
    result = lm.minimize(lm_residual, params, method = 'least_squares', args = (x, data))
    gaussmod = gauss_curve(x, result.params['cen1'].value, result.params['amp1'].value, result.params['wid1'].value)

    fig, [ax0, ax1, ax2] = plt.subplots(1,3)
    fig.set_size_inches(7,2.5)    
    ax0.plot(np.linspace(0,80,200), data_o, 'k', markevery=10, label = 'CFD - mean')
    ax0.fill_between(np.linspace(0,80,200), large['icr'].min(1), large['icr'].max(1), color = 'silver', alpha = 0.4, label = 'CFD - range')       
    ax0.plot(np.linspace(0,80,200), gaussmod[int(len(gaussmod)/2)::], 'r--', lw = 1.5, label = 'model')    
    ax1.plot(np.linspace(0,80,200), large['icr'].max(1) - gaussmod[int(len(gaussmod)/2)::], ls = 'None', marker = 's', mfc = 'none', mec='k',  ms = 3., markevery = 8)
    ax0.set_xlim(0,80)
    ax0.set_ylim(0, 1)
    ax1.set_xlim(0,80)
    ax1.set_ylim(-0.1, 0.1)
    #text_gaussian1 = r"$f(\theta) = exp \left( \frac{-\left( \frac{\theta}{160}\right) ^2}{2 \times {%.3f}^2} \right)$" % (result.params['wid1'].value)    
    #ax1.text(0.05, 0.2, text_gaussian1, fontsize = 'small', transform=ax1.transAxes)       
    ax1.set_ylim(-0.1, 0.1) 
    ax1.set_xlim(0,80)
    RSS = np.power(small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::],2).sum()
    RSE = ( (1/(len(small['icr'].mean(1) - gaussmod[int(len(gaussmod)/2)::])-2)) * RSS  )
    if RSE < 0.0001:
        text_RSE = "$RSE < 0.0001$"
    else:
        text_RSE = "$RSE = {:.3f}$".format(RSE)   
    ax1.text(0.05,0.05, text_RSE, fontsize='x-small', transform=ax1.transAxes)    
    res1 = stats.probplot(data_o - gaussmod[int(len(gaussmod)/2)::], plot=ax2)
    ax2.text(0.55, 0.25, r"$R^2 = $"+str(round(res1[1][2]**2, 3)), fontsize = 'x-small', transform=ax2.transAxes)
    ax2.get_lines()[0].set_marker('s')
    ax2.get_lines()[0].set_markerfacecolor('none')
    ax2.get_lines()[0].set_markeredgecolor('k')
    ax2.get_lines()[0].set_markersize(3.)
    ax2.get_lines()[0].set_markevery(6)   
    ax2.set_title("")
    ax2.set_xlim(-2.5,2.5)
    ax2.set_ylim(-0.05, 0.1)
    ax0.set_xlabel('angle of incidence (degrees)')
    ax0.set_ylabel('peak specific impulse ratio')
    handles, labels = ax0.get_legend_handles_labels()
    ax0.legend(handles, labels, loc='upper right', prop={'size':6})
    ax1.set_xlabel('angle of incidence (degrees)')
    ax1.set_ylabel('Residual')
    ax0.minorticks_on()
    ax0.grid(which='minor', alpha=0.2)
    ax0.grid(which='major', alpha=0.5)
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    ax2.minorticks_on()
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5) 
    ax0.locator_params(axis = 'both',tight=True, nbins=6)
    ax1.locator_params(axis = 'both',tight=True, nbins=6)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\model_gaussian1_largez.pdf', format = 'pdf')      
    return gaussmod
large['gaussmod'] = my_model_graphs_large()      



#Build surface from Guassian Eq and power law.
def plot_model_surfaces(dataset):
    theta = np.repeat(np.linspace(0,80, dataset['imp'].shape[0])[:,np.newaxis], dataset['imp'].shape[1], 1) 
    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, dataset['imp'].shape[0], 0)    
    
    
    peak_i_mod = np.multiply(np.power(z, dataset['slope']), dataset['const'])    #scaledpeakimpulses
    theta_dist = dataset['gaussmod'][int(len(dataset['gaussmod'])/2)::]
    theta_dist = theta_dist.reshape((len(theta_dist), 1))
    theta_dist = np.repeat(theta_dist, peak_i_mod.shape[1], axis=1) 
    
    i_surf = np.multiply(theta_dist, peak_i_mod)

    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(3, 2.5)
    CS = ax.contourf(theta, z, i_surf, levels = np.linspace(0,25,50), cmap = plt.cm.magma_r)
    cbar = fig.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,25,6))
    cbar.ax.set_ylabel('scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', fontsize = 'x-small')
    ax.set_ylabel('scaled distance, z ' + r'$(m/kg^{\frac{1}{3}}$)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    
    fig2, ax = plt.subplots(1,1)
    fig2.set_size_inches(3, 2.5)
    diff = i_surf-(dataset['imp_smooth']/1e3/((cm*TNTeq)**(1/3)))
    # CS = ax.contourf(theta, z, diff, levels = np.linspace(0,2.5,50), cmap = plt.cm.magma_r)
    # cbar = fig2.colorbar(CS, format='%.1f' ,ticks = np.linspace(0,2.5,6))
    CS = ax.contourf(theta, z, diff, levels = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 2),50), cmap = plt.cm.magma_r)
    cbar = fig2.colorbar(CS, format='%.0f' , ticks = np.linspace(rounddwn(diff.min(), base = 1),roundup(diff.max(), base = 2),5))  
    cbar.ax.set_ylabel('scaled specific impulse'+r'$(MPa.ms/kg^{\frac{1}{3}}$)', fontsize = 'x-small')
    ax.set_ylabel('scaled distance, z ' + r'$(m/kg^{\frac{1}{3}}$)')
    ax.set_xlabel('incident wave angle (degrees)')
    plt.tight_layout()
    return i_surf, fig, fig2
small['gauss_surf'], fig, fig2 = plot_model_surfaces(small)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_gaussian1.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_gaussian2.pdf', format = 'pdf')
large['gauss_surf'], fig, fig2 = plot_model_surfaces(large)
fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_gaussian1.pdf', format = 'pdf')
fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_gaussian2.pdf', format = 'pdf')
   

def TotalImpulseSurfaces(dataset):
    max_target_length = 2.5
    upper_theta = 80
    theta_lim = np.linspace(0,upper_theta,80)   
    R = np.divide(max_target_length, np.tan(np.deg2rad(upper_theta))) 
    theta_test = np.repeat(theta_lim.reshape(len(theta_lim),1), dataset['imp'].shape[1], 1)    
    target_rad = np.multiply(np.tan(np.deg2rad(theta_test)), R)   
    target_rad = np.divide(target_rad, ((cm*TNTeq)**(1/3)))#scaled target radius
    

    
    Imp_CFD = np.zeros_like(target_rad)
    Imp_gauss = np.zeros_like(Imp_CFD)
    for i in range(Imp_CFD.shape[0]):
        for j in range(Imp_CFD.shape[1]):       
            Imp_CFD[i,j] = Impulse_CFD(dataset['imp_smooth'][:,j], R, theta_lim[i], np.linspace(0,80,200))
            Imp_gauss[i,j] = Impulse_CFD(dataset['gauss_surf'][:,j]*1e3*((cm*TNTeq)**(1/3)), R, theta_lim[i], np.linspace(0,80,200))
    
    return Imp_CFD, Imp_gauss
# small['CFD_total_impulse'], small['gauss_total_impulse'] = TotalImpulseSurfaces(small)
# large['CFD_total_impulse'], large['gauss_total_impulse'] = TotalImpulseSurfaces(large)


def graphTotalImpulseSurfaces(dataset):
    max_target_length = 2.5
    upper_theta = 80
    theta_lim = np.linspace(0,upper_theta,len(dataset['gauss_total_impulse']))  
    R = np.divide(max_target_length, np.tan(np.deg2rad(upper_theta))) 
    theta_test = np.repeat(theta_lim.reshape(len(theta_lim),1), dataset['imp'].shape[1], 1)    
    target_rad = np.multiply(np.tan(np.deg2rad(theta_test)), R)   
    target_rad = np.divide(target_rad, ((cm*TNTeq)**(1/3)))#scaled target radius

    z = dataset['z']
    z = z.reshape((dataset['imp'].shape[1], 1))
    z = z.T
    z = np.repeat(z, len(target_rad), 0) 

    
    fig_test, ax = plt.subplots(1,1)
    fig_test.set_size_inches(3, 2.5)
    CS = ax.contourf(target_rad, z, dataset['gauss_total_impulse']/1e3/0.1, levels = np.linspace(0,roundup((dataset['gauss_total_impulse']/1e3/0.1).max(), base = 200),50), cmap = plt.cm.magma_r)
    cbar = fig_test.colorbar(CS, format='%.0f' ,ticks = np.linspace(0,roundup((dataset['gauss_total_impulse']/1e3/0.1).max(), base = 200),5))
    cbar.ax.set_ylabel('total scaled impulse' +  r'$(MN.ms/kg)$')
    ax.set_ylabel('scaled distance, z ' + r'$(m/kg^{\frac{1}{3}}$)')
    ax.set_xlabel('scaled target radius'+r'$(m/kg^{\frac{1}{3}}$)')
    plt.tight_layout()
       
    
    fig_test2, ax = plt.subplots(1,1)
    fig_test2.set_size_inches(3, 2.5)
    diff = (dataset['gauss_total_impulse'] - dataset['CFD_total_impulse'])/1e3/0.1
    CS = ax.contourf(target_rad, z, diff, levels = np.linspace(rounddwn(diff.min(), base = 20),roundup(diff.max(), base = 20),50), cmap = plt.cm.magma_r)
    cbar = fig_test2.colorbar(CS, format='%.0f' , ticks = np.linspace(rounddwn(diff.min(), base = 20),roundup(diff.max(), base = 20),5))   
    cbar.ax.set_ylabel('total scaled impulse' +  r'$(MN.ms/kg)$')
    ax.set_ylabel('scaled distance, z ' + r'$(m/kg^{\frac{1}{3}}$)')
    ax.set_xlabel('scaled target radius'+r'$(m/kg^{\frac{1}{3}}$)')
    plt.tight_layout()
    return  fig_test, fig_test2
# fig1, fig2 = graphTotalImpulseSurfaces(small)
# fig1.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_totalimpulse_gauss.pdf', format = 'pdf')
# fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\smallz_totalimpulse_gauss2.pdf', format = 'pdf')
# fig1, fig2 = graphTotalImpulseSurfaces(large)
# fig1.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_totalimpulse_gauss.pdf', format = 'pdf')
# fig2.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\largez_totalimpulse_gauss2.pdf', format = 'pdf')
 
 
def new1():
    val_highZ = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\250kg\res3", 250,TNTeq, sav=101)
    val_lowZ = dataimport(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\5kg\res3", 5,TNTeq, sav=101)
    
    #Radial ordinate calcs
    radial_ord_lowZ = [0,0.125, 0.250, 0.375, 0.500]
    theta_ord_lowZ = np.rad2deg(np.arctan(np.divide(radial_ord_lowZ, val_lowZ['so'])))
    lowZi_eq5 = ( (5)**(1/3) * 
                 (val_lowZ['z'][0]**-1.858) * 0.383 *
                 np.exp(-(theta_ord_lowZ/160)**2 / (2*0.189**2)) )
    lowZi_eq6 = 
    radial_ord_highZ = [0,1.125, 2.250, 3.375, 4.500]
    theta_ord_highZ = np.rad2deg(np.arctan(np.divide(radial_ord_highZ, val_highZ['so'])))  
    
    
    theta = np.linspace(0,80,200)
    
    lowz = ( (5)**(1/3) * 
            (val_lowZ['z'][0]**-1.858) * 0.383 *
            np.exp(-(theta/160)**2 / (2*0.189**2)) )
    
    highz = ( (250)**(1/3) * 
            (val_highZ['z'][0]**-1.663) * 0.557 *
            np.exp(-(theta/160)**2 / (2*0.198**2)) )
    
    
    fig, ax1 = plt.subplots(1,1)
    fig.set_size_inches(2.5, 2.5) 
    ax1.plot(theta, val_lowZ['imp_smooth']/1e3, 'k', ls = '-', lw = 0.5, label = 'CFD')
    ax1.plot(theta, lowz, 'r', ls = '-', lw = 1.5,label = 'new model')
    handles, labels = ax1.get_legend_handles_labels()
    ax1.legend(handles, labels, loc='upper right', prop={'size':6})
    
    ax1.set_xlabel('incident wave angle (degrees)')
    ax1.set_ylabel('peak specific impulse'+r'$(MPa.ms$)', fontsize = 'small')
    ax1.set_xlim(0,80)
    #ax1.set_ylim(0,9)
    ax1.minorticks_on()
    ax1.grid(which='minor', alpha=0.2)
    ax1.grid(which='major', alpha=0.5)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\lowz_val.pdf', format = 'pdf')
 
    fig, ax2 = plt.subplots(1,1)
    fig.set_size_inches(2.5, 2.5)    
    ax2.plot(theta, val_highZ['imp_smooth']/1e3, 'k', ls = '-', lw = 0.5, label = 'CFD')
    ax2.plot(theta, highz, 'r', ls = '-', lw = 1.5)
    
    ax2.set_xlabel('incident wave angle (degrees)')
    ax2.set_ylabel('peak specific impulse'+r'$(MPa.ms$)', fontsize = 'small')
    ax2.set_xlim(0,80)
    #ax2.set_ylim(0,0.7)
    ax2.minorticks_on()
    ax2.grid(which='minor', alpha=0.2)
    ax2.grid(which='major', alpha=0.5)
    plt.tight_layout()
    fig.savefig(os.environ['USERPROFILE'] + r'\Dropbox\Papers\Paper_1_near_field_spherical_prediction\Graphs\highz_val.pdf', format = 'pdf')


    data5kg = pre.FileAddressList(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\5kg\res2"+ r"\*gauges", 1)
    data250kg = pre.FileAddressList(os.environ['USERPROFILE'] + r"\Google Drive\Apollo Sims\Impulse Distribution Curve Modelling\Paper_1\Sphere\validation_samples\250kg\res2"+ r"\*gauges", 1)
    
    fig00, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2,2)
    #theta = 0
    ax1.plot(data5kg[0][:,0],data5kg[0][:,1]) #OP
    ax1.set_xlim(0,0.003)
    ax2.plot(data5kg[0][:,0],data5kg[0][:,201])#imp
    ax2.set_xlim(0,0.003)
    #theta = 80
    ax3.plot(data5kg[0][:,0],data5kg[0][:,200])#OP
    ax3.set_xlim(0,0.003)
    ax4.plot(data5kg[0][:,0],data5kg[0][:,400])#imp
    ax4.set_xlim(0,0.003)
    
    fig00, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2,2)
    #theta = 0
    ax1.plot(data250kg[0][:,0],data250kg[0][:,1]) #OP
    ax1.set_xlim(0,0.03)
    ax2.plot(data250kg[0][:,0],data250kg[0][:,201])#imp
    ax2.set_xlim(0,0.03)
    #theta = 80
    ax3.plot(data250kg[0][:,0],data250kg[0][:,200])#OP
    ax3.set_xlim(0,0.03)
    ax4.plot(data250kg[0][:,0],data250kg[0][:,400])#imp
    ax4.set_xlim(0,0.03)  